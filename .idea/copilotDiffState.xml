<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/cloud/FirebaseService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/cloud/FirebaseService.kt" />
              <option name="originalContent" value="package com.example.myapplication.cloud&#10;&#10;import android.content.Context&#10;import android.net.Uri&#10;import android.util.Base64&#10;import android.util.Log&#10;import com.example.myapplication.model.UsuarioEntity&#10;import com.google.firebase.FirebaseApp&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.firestore.ListenerRegistration&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.firestore.FieldValue&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlin.coroutines.resume&#10;import java.io.ByteArrayOutputStream&#10;import java.io.InputStream&#10;&#10;object FirebaseService {&#10;    // Instancia de Firestore&#10;    private val db: FirebaseFirestore&#10;        get() = FirebaseFirestore.getInstance()&#10;&#10;    // --- Estado para panel admin en realtime ---&#10;    private var adminUsersListener: ListenerRegistration? = null&#10;    private var adminProfilesListener: ListenerRegistration? = null&#10;    private val adminUsersMap = mutableMapOf&lt;String, MutableMap&lt;String, Any&gt;&gt;()&#10;    private val adminProfilesMap = mutableMapOf&lt;String, Map&lt;String, Any&gt;&gt;()&#10;    private var adminCallback: ((List&lt;Map&lt;String, Any&gt;&gt;) -&gt; Unit)? = null&#10;&#10;    // Fusiona users + profiles y notifica al callback&#10;    private fun mergeAndNotifyAdmin() {&#10;        try {&#10;            val merged = adminUsersMap.values.map { u -&gt;&#10;                val mergedMap = u.toMutableMap()&#10;                val email = u[&quot;email&quot;]?.toString() ?: &quot;&quot;&#10;                val docIdFromEmail = sanitizeDocId(email)&#10;                val profileKey = docIdFromEmail ?: (u[&quot;firebaseDocId&quot;]?.toString())&#10;                val profile = profileKey?.let { adminProfilesMap[it] }&#10;&#10;                if (profile != null &amp;&amp; profile.isNotEmpty()) {&#10;                    profile[&quot;name&quot;]?.let { if (it.toString().isNotEmpty()) mergedMap[&quot;name&quot;] = it }&#10;                    profile[&quot;photo&quot;]?.let { if (it.toString().isNotEmpty()) mergedMap[&quot;photo&quot;] = it }&#10;                    profile[&quot;city&quot;]?.let { if (it.toString().isNotEmpty()) mergedMap[&quot;city&quot;] = it }&#10;                    profile[&quot;description&quot;]?.let { if (it.toString().isNotEmpty()) mergedMap[&quot;description&quot;] = it }&#10;                }&#10;&#10;                // Campos mínimos&#10;                if (!mergedMap.containsKey(&quot;name&quot;)) mergedMap[&quot;name&quot;] = &quot;&quot;&#10;                if (!mergedMap.containsKey(&quot;email&quot;)) mergedMap[&quot;email&quot;] = &quot;&quot;&#10;                if (!mergedMap.containsKey(&quot;photo&quot;)) mergedMap[&quot;photo&quot;] = &quot;&quot;&#10;                if (!mergedMap.containsKey(&quot;blocked&quot;)) mergedMap[&quot;blocked&quot;] = false&#10;                if (!mergedMap.containsKey(&quot;suspended&quot;)) mergedMap[&quot;suspended&quot;] = false&#10;                if (!mergedMap.containsKey(&quot;posts&quot;)) mergedMap[&quot;posts&quot;] = 0&#10;                if (!mergedMap.containsKey(&quot;joinDate&quot;)) mergedMap[&quot;joinDate&quot;] = &quot;&quot;&#10;                if (!mergedMap.containsKey(&quot;lastLogin&quot;)) mergedMap[&quot;lastLogin&quot;] = &quot;&quot;&#10;&#10;                mergedMap.toMap()&#10;            }&#10;&#10;            Log.d(&quot;FirebaseService&quot;, &quot;Notificando merged users: ${merged.size}&quot;)&#10;            adminCallback?.invoke(merged)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error al mergear usuarios y profiles: ${e.message}&quot;, e)&#10;            adminCallback?.invoke(emptyList())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ADMIN: Suscribe en tiempo real a 'usuarios' y 'userProfiles' y llama callback con la lista fusionada.&#10;     * Si ya hay listeners activos, sólo reemplaza el callback y notifica con el estado actual.&#10;     */&#10;    fun loadAllUsersForAdmin(callback: (List&lt;Map&lt;String, Any&gt;&gt;) -&gt; Unit) {&#10;        adminCallback = callback&#10;&#10;        // Si ya están los listeners, notificar inmediatamente&#10;        if (adminUsersListener != null || adminProfilesListener != null) {&#10;            mergeAndNotifyAdmin()&#10;            return&#10;        }&#10;&#10;        adminUsersListener = db.collection(&quot;usuarios&quot;)&#10;            .addSnapshotListener { snapshot, e -&gt;&#10;                if (e != null) {&#10;                    Log.e(&quot;FirebaseService&quot;, &quot;Error al escuchar 'usuarios': ${e.message}&quot;, e)&#10;                    return@addSnapshotListener&#10;                }&#10;&#10;                if (snapshot != null) {&#10;                    for (docChange in snapshot.documentChanges) {&#10;                        val doc = docChange.document&#10;                        val docId = doc.id&#10;                        val data = doc.data&#10;&#10;                        when (docChange.type) {&#10;                            com.google.firebase.firestore.DocumentChange.Type.ADDED,&#10;                            com.google.firebase.firestore.DocumentChange.Type.MODIFIED -&gt; {&#10;                                if (data != null) {&#10;                                    adminUsersMap[docId] = data.toMutableMap()&#10;                                    adminUsersMap[docId]?.put(&quot;firebaseDocId&quot;, docId)&#10;                                }&#10;                            }&#10;                            com.google.firebase.firestore.DocumentChange.Type.REMOVED -&gt; {&#10;                                adminUsersMap.remove(docId)&#10;                            }&#10;                        }&#10;                    }&#10;                    mergeAndNotifyAdmin()&#10;                }&#10;            }&#10;&#10;        adminProfilesListener = db.collection(&quot;userProfiles&quot;)&#10;            .addSnapshotListener { snapshot, e -&gt;&#10;                if (e != null) {&#10;                    Log.e(&quot;FirebaseService&quot;, &quot;Error al escuchar 'userProfiles': ${e.message}&quot;, e)&#10;                    return@addSnapshotListener&#10;                }&#10;&#10;                if (snapshot != null) {&#10;                    for (docChange in snapshot.documentChanges) {&#10;                        val doc = docChange.document&#10;                        val docId = doc.id&#10;                        val data = doc.data&#10;&#10;                        when (docChange.type) {&#10;                            com.google.firebase.firestore.DocumentChange.Type.ADDED,&#10;                            com.google.firebase.firestore.DocumentChange.Type.MODIFIED -&gt; {&#10;                                if (data != null) adminProfilesMap[docId] = data&#10;                            }&#10;                            com.google.firebase.firestore.DocumentChange.Type.REMOVED -&gt; {&#10;                                adminProfilesMap.remove(docId)&#10;                            }&#10;                        }&#10;                    }&#10;                    mergeAndNotifyAdmin()&#10;                }&#10;            }&#10;    }&#10;&#10;    /**&#10;     * Detiene listeners del admin y limpia el estado.&#10;     */&#10;    fun stopAdminListeners() {&#10;        try { adminUsersListener?.remove() } catch (_: Exception) {}&#10;        adminUsersListener = null&#10;        try { adminProfilesListener?.remove() } catch (_: Exception) {}&#10;        adminProfilesListener = null&#10;        adminUsersMap.clear()&#10;        adminProfilesMap.clear()&#10;        adminCallback = null&#10;    }&#10;&#10;    // ------------------ Resto de utilidades del servicio ------------------&#10;&#10;    private fun getStorageBucketUrl(): String {&#10;        return try {&#10;            val cfg = FirebaseApp.getInstance().options.storageBucket&#10;            if (!cfg.isNullOrEmpty()) {&#10;                var bucket = cfg&#10;                if (bucket.endsWith(&quot;firebasestorage.app&quot;)) bucket = bucket.replace(&quot;firebasestorage.app&quot;, &quot;appspot.com&quot;)&#10;                if (!bucket.startsWith(&quot;gs://&quot;)) bucket = &quot;gs://$bucket&quot;&#10;                bucket&#10;            } else {&#10;                &quot;gs://tamats-aea71.appspot.com&quot;&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;FirebaseService&quot;, &quot;Error leyendo storageBucket: ${e.message}&quot;)&#10;            &quot;gs://tamats-aea71.appspot.com&quot;&#10;        }&#10;    }&#10;&#10;    fun guardarUsuario(usuario: UsuarioEntity) {&#10;        if (esContrasenaPlana(usuario.passwordHash)) {&#10;            Log.e(&quot;FirebaseService&quot;, &quot;ERROR: Contraseña sin cifrar. Use EncryptionUtil.encryptPassword().&quot;)&#10;            return&#10;        }&#10;&#10;        val data = mapOf(&#10;            &quot;name&quot; to usuario.name,&#10;            &quot;email&quot; to usuario.email,&#10;            &quot;birthDate&quot; to usuario.birthDate,&#10;            &quot;gender&quot; to usuario.gender,&#10;            &quot;passwordHash&quot; to usuario.passwordHash,&#10;            &quot;blocked&quot; to false,&#10;            &quot;suspended&quot; to false,&#10;            &quot;suspensionEnd&quot; to null,&#10;            &quot;posts&quot; to 0,&#10;            &quot;photo&quot; to &quot;&quot;,&#10;            &quot;joinDate&quot; to Timestamp.now(),&#10;            &quot;lastLogin&quot; to Timestamp.now()&#10;        )&#10;&#10;        val docId = usuario.email.replace(Regex(&quot;[^a-zA-Z0-9._-]&quot;), &quot;_&quot;)&#10;        db.collection(&quot;usuarios&quot;).document(docId).set(data)&#10;            .addOnSuccessListener { Log.d(&quot;FirebaseService&quot;, &quot;Usuario guardado: $docId&quot;) }&#10;            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;, &quot;Error guardando usuario: ${e.message}&quot;, e) }&#10;    }&#10;&#10;    private fun esContrasenaPlana(passwordHash: String): Boolean {&#10;        return passwordHash.length == 8 &amp;&amp; passwordHash.matches(Regex(&quot;[a-zA-Z0-9]*&quot;))&#10;    }&#10;&#10;    fun obtenerUsuarios(callback: (List&lt;UsuarioEntity&gt;) -&gt; Unit) {&#10;        db.collection(&quot;usuarios&quot;).get()&#10;            .addOnSuccessListener { result -&gt;&#10;                val lista = result.map { doc -&gt;&#10;                    UsuarioEntity(&#10;                        id = 0,&#10;                        name = doc.getString(&quot;name&quot;) ?: &quot;&quot;,&#10;                        email = doc.getString(&quot;email&quot;) ?: &quot;&quot;,&#10;                        birthDate = doc.getString(&quot;birthDate&quot;) ?: &quot;&quot;,&#10;                        gender = doc.getString(&quot;gender&quot;) ?: &quot;&quot;,&#10;                        passwordHash = doc.getString(&quot;passwordHash&quot;) ?: &quot;&quot;&#10;                    )&#10;                }&#10;                callback(lista)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error al obtener usuarios: ${e.message}&quot;, e)&#10;                callback(emptyList())&#10;            }&#10;    }&#10;&#10;    fun findUserByEmail(email: String, callback: (UsuarioEntity?) -&gt; Unit) {&#10;        db.collection(&quot;usuarios&quot;).whereEqualTo(&quot;email&quot;, email).limit(1).get()&#10;            .addOnSuccessListener { documents -&gt;&#10;                if (!documents.isEmpty) {&#10;                    val doc = documents.first()&#10;                    val user = UsuarioEntity(&#10;                        id = 0,&#10;                        name = doc.getString(&quot;name&quot;) ?: &quot;&quot;,&#10;                        email = doc.getString(&quot;email&quot;) ?: &quot;&quot;,&#10;                        birthDate = doc.getString(&quot;birthDate&quot;) ?: &quot;&quot;,&#10;                        gender = doc.getString(&quot;gender&quot;) ?: &quot;&quot;,&#10;                        passwordHash = doc.getString(&quot;passwordHash&quot;) ?: &quot;&quot;&#10;                    )&#10;                    callback(user)&#10;                } else {&#10;                    val docId = email.replace(Regex(&quot;[^a-zA-Z0-9._-]&quot;), &quot;_&quot;)&#10;                    db.collection(&quot;usuarios&quot;).document(docId).get()&#10;                        .addOnSuccessListener { doc -&gt;&#10;                            if (doc.exists()) {&#10;                                val user = UsuarioEntity(&#10;                                    id = 0,&#10;                                    name = doc.getString(&quot;name&quot;) ?: &quot;&quot;,&#10;                                    email = doc.getString(&quot;email&quot;) ?: &quot;&quot;,&#10;                                    birthDate = doc.getString(&quot;birthDate&quot;) ?: &quot;&quot;,&#10;                                    gender = doc.getString(&quot;gender&quot;) ?: &quot;&quot;,&#10;                                    passwordHash = doc.getString(&quot;passwordHash&quot;) ?: &quot;&quot;&#10;                                )&#10;                                callback(user)&#10;                            } else callback(null)&#10;                        }&#10;                        .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;, &quot;Error buscando por ID: ${e.message}&quot;, e); callback(null) }&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;, &quot;Error buscando por email: ${e.message}&quot;, e); callback(null) }&#10;    }&#10;&#10;    @Suppress(&quot;unused&quot;)&#10;    fun uploadImage(uri: Uri, context: Context, callback: (String?) -&gt; Unit) {&#10;        try {&#10;            val base64 = uriToBase64(context, uri)&#10;            callback(base64)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error uploadImage: ${e.message}&quot;, e)&#10;            callback(null)&#10;        }&#10;    }&#10;&#10;    @Suppress(&quot;unused&quot;)&#10;    suspend fun uploadImageSuspend(uri: Uri, context: Context): String? = suspendCancellableCoroutine { cont -&gt;&#10;        try {&#10;            val b64 = uriToBase64(context, uri)&#10;            if (cont.isActive) cont.resume(b64)&#10;        } catch (e: Exception) {&#10;            if (cont.isActive) cont.resume(null)&#10;        }&#10;    }&#10;&#10;    private fun uriToBase64(context: Context, uri: Uri, maxBytes: Int = 900 * 1024): String? {&#10;        var input: InputStream? = null&#10;        try {&#10;            input = context.contentResolver.openInputStream(uri) ?: return null&#10;            val buffer = ByteArray(8192)&#10;            val baos = ByteArrayOutputStream()&#10;            var read: Int&#10;            while (true) {&#10;                read = input.read(buffer)&#10;                if (read &lt;= 0) break&#10;                baos.write(buffer, 0, read)&#10;            }&#10;            val rawBytes = baos.toByteArray()&#10;            val directB64 = Base64.encodeToString(rawBytes, Base64.NO_WRAP)&#10;            if (directB64.toByteArray(Charsets.UTF_8).size &lt;= maxBytes) return directB64&#10;        } catch (e: Exception) {&#10;            Log.w(&quot;FirebaseService&quot;, &quot;Lectura directa falló: ${e.message}&quot;)&#10;        } finally {&#10;            try { input?.close() } catch (_: Exception) {}&#10;        }&#10;&#10;        // Intentar con Bitmap y compresión (omito detalles para mantener legible)&#10;        try {&#10;            var bitmapInput: InputStream? = null&#10;            val optionsBounds = android.graphics.BitmapFactory.Options()&#10;            optionsBounds.inJustDecodeBounds = true&#10;            bitmapInput = context.contentResolver.openInputStream(uri) ?: return null&#10;            android.graphics.BitmapFactory.decodeStream(bitmapInput, null, optionsBounds)&#10;            bitmapInput.close()&#10;&#10;            var sampleSize = 1&#10;            val desiredMaxDim = 1280&#10;            val width = optionsBounds.outWidth&#10;            val height = optionsBounds.outHeight&#10;            if (width &gt; desiredMaxDim || height &gt; desiredMaxDim) {&#10;                val scale = Math.max(width / desiredMaxDim, height / desiredMaxDim)&#10;                var s = 1&#10;                while (s &lt; scale) s *= 2&#10;                sampleSize = s&#10;            }&#10;&#10;            val optionsDecode = android.graphics.BitmapFactory.Options()&#10;            optionsDecode.inSampleSize = sampleSize&#10;            bitmapInput = context.contentResolver.openInputStream(uri) ?: return null&#10;            val bmp = android.graphics.BitmapFactory.decodeStream(bitmapInput, null, optionsDecode)&#10;            bitmapInput.close()&#10;            if (bmp == null) return null&#10;&#10;            val baos2 = ByteArrayOutputStream()&#10;            var quality = 85&#10;            while (quality &gt;= 30) {&#10;                baos2.reset()&#10;                bmp.compress(android.graphics.Bitmap.CompressFormat.JPEG, quality, baos2)&#10;                val compressed = baos2.toByteArray()&#10;                val b64 = Base64.encodeToString(compressed, Base64.NO_WRAP)&#10;                if (b64.toByteArray(Charsets.UTF_8).size &lt;= maxBytes) return b64&#10;                quality -= 10&#10;            }&#10;&#10;            // Si no entra, reducir dimensiones iterativamente&#10;            var currentWidth = bmp.width&#10;            var currentHeight = bmp.height&#10;            var reducedBmp: android.graphics.Bitmap? = bmp&#10;            while (true) {&#10;                val newW = (currentWidth * 0.75).toInt().coerceAtLeast(100)&#10;                val newH = (currentHeight * 0.75).toInt().coerceAtLeast(100)&#10;                if (newW &gt;= currentWidth || newH &gt;= currentHeight) break&#10;                val scaled = android.graphics.Bitmap.createScaledBitmap(reducedBmp!!, newW, newH, true)&#10;                if (reducedBmp !== bmp) try { reducedBmp.recycle() } catch (_: Exception) {}&#10;                reducedBmp = scaled&#10;                currentWidth = reducedBmp.width&#10;                currentHeight = reducedBmp.height&#10;&#10;                baos2.reset()&#10;                reducedBmp.compress(android.graphics.Bitmap.CompressFormat.JPEG, 70, baos2)&#10;                val compressed = baos2.toByteArray()&#10;                val b64try = Base64.encodeToString(compressed, Base64.NO_WRAP)&#10;                if (b64try.toByteArray(Charsets.UTF_8).size &lt;= maxBytes) return b64try&#10;                if (currentWidth &lt;= 200 || currentHeight &lt;= 200) break&#10;            }&#10;&#10;            return null&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error procesando bitmap: ${e.message}&quot;, e)&#10;            return null&#10;        }&#10;    }&#10;&#10;    private fun sanitizeDocId(id: String?): String? {&#10;        if (id.isNullOrBlank()) return null&#10;        return id.replace(&quot;/&quot;, &quot;_&quot;)&#10;    }&#10;&#10;    fun saveUserProfile(email: String, profileData: Map&lt;String, Any&gt;, callback: (Boolean) -&gt; Unit) {&#10;        db.collection(&quot;usuarios&quot;).whereEqualTo(&quot;email&quot;, email).limit(1).get()&#10;            .addOnSuccessListener { documents -&gt;&#10;                if (documents.isEmpty) {&#10;                    val docId = sanitizeDocId(email)&#10;                    if (docId != null) {&#10;                        db.collection(&quot;userProfiles&quot;).document(docId).set(profileData)&#10;                            .addOnSuccessListener { callback(true) }&#10;                            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error saveUserProfile: ${e.message}&quot;, e); callback(false) }&#10;                    } else {&#10;                        db.collection(&quot;userProfiles&quot;).add(profileData)&#10;                            .addOnSuccessListener { callback(true) }&#10;                            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error saveUserProfile auto-id: ${e.message}&quot;, e); callback(false) }&#10;                    }&#10;                } else {&#10;                    val doc = documents.first()&#10;                    val existingId = doc.id&#10;                    val existingCollection = doc.reference.parent.id&#10;                    val updates = profileData.mapValues { it.value as Any }&#10;                    db.collection(existingCollection).document(existingId)&#10;                        .update(updates)&#10;                        .addOnSuccessListener { callback(true) }&#10;                        .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error update profile: ${e.message}&quot;, e); callback(false) }&#10;                }&#10;            }&#10;            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error finding user for saveUserProfile: ${e.message}&quot;, e); callback(false) }&#10;    }&#10;&#10;    fun getUserProfile(email: String, callback: (Map&lt;String, Any&gt;?) -&gt; Unit) {&#10;        val docId = sanitizeDocId(email)&#10;        if (docId != null) {&#10;            db.collection(&quot;userProfiles&quot;).document(docId).get()&#10;                .addOnSuccessListener { document -&gt;&#10;                    if (document.exists()) callback(document.data) else {&#10;                        db.collection(&quot;usuarios&quot;).whereEqualTo(&quot;email&quot;, email).limit(1).get()&#10;                            .addOnSuccessListener { docs -&gt; if (!docs.isEmpty) callback(docs.first().data) else callback(null) }&#10;                            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error getUserProfile usuarios: ${e.message}&quot;, e); callback(null) }&#10;                    }&#10;                }&#10;                .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error getUserProfile userProfiles: ${e.message}&quot;, e); callback(null) }&#10;        } else {&#10;            db.collection(&quot;usuarios&quot;).whereEqualTo(&quot;email&quot;, email).limit(1).get()&#10;                .addOnSuccessListener { docs -&gt; if (!docs.isEmpty) callback(docs.first().data) else callback(null) }&#10;                .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error getUserProfile usuarios fallback: ${e.message}&quot;, e); callback(null) }&#10;        }&#10;    }&#10;&#10;    fun getCurrentUserEmail(): String {&#10;        return try {&#10;            val auth = FirebaseAuth.getInstance()&#10;            auth.currentUser?.email ?: &quot;&quot;&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error obteniendo email: ${e.message}&quot;, e)&#10;            &quot;&quot;&#10;        }&#10;    }&#10;&#10;    fun logout(context: Context? = null) {&#10;        try {&#10;            FirebaseAuth.getInstance().signOut()&#10;            context?.let {&#10;                val prefs = it.getSharedPreferences(&quot;user_data&quot;, Context.MODE_PRIVATE)&#10;                prefs.edit().clear().apply()&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error logout: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * ADMIN: Bloquea un usuario (marca blocked = true, suspended = false)&#10;     */&#10;    fun blockUser(userId: String, callback: (Boolean, String) -&gt; Unit) {&#10;        val updates = mapOf&lt;String, Any&gt;(&#10;            &quot;blocked&quot; to true,&#10;            &quot;suspended&quot; to false,&#10;            // eliminar el campo suspensionEnd si existía&#10;            &quot;suspensionEnd&quot; to FieldValue.delete()&#10;        )&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#10;            .update(updates)&#10;            .addOnSuccessListener {&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Usuario $userId bloqueado en Firestore&quot;)&#10;                callback(true, &quot;Usuario bloqueado exitosamente&quot;)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error bloqueando usuario $userId: ${e.message}&quot;, e)&#10;                callback(false, &quot;Error al bloquear usuario: ${e.message}&quot;)&#10;            }&#10;    }&#10;&#10;    /**&#10;     * ADMIN: Desbloquea un usuario (marca blocked = false)&#10;     */&#10;    fun unblockUser(userId: String, callback: (Boolean, String) -&gt; Unit) {&#10;        val updates = mapOf&lt;String, Any&gt;(&quot;blocked&quot; to false)&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#10;            .update(updates)&#10;            .addOnSuccessListener {&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Usuario $userId desbloqueado en Firestore&quot;)&#10;                callback(true, &quot;Usuario desbloqueado exitosamente&quot;)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error desbloqueando usuario $userId: ${e.message}&quot;, e)&#10;                callback(false, &quot;Error al desbloquear usuario: ${e.message}&quot;)&#10;            }&#10;    }&#10;&#10;    /**&#10;     * ADMIN: Suspende un usuario por X días (marca suspended = true y suspensionEnd en millis)&#10;     */&#10;    fun suspendUser(userId: String, days: Int, callback: (Boolean, String) -&gt; Unit) {&#10;        val suspensionEnd = System.currentTimeMillis() + (days * 24L * 60L * 60L * 1000L)&#10;        val updates = mapOf&lt;String, Any&gt;(&#10;            &quot;suspended&quot; to true,&#10;            &quot;suspensionEnd&quot; to suspensionEnd,&#10;            &quot;blocked&quot; to false&#10;        )&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#10;            .update(updates)&#10;            .addOnSuccessListener {&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Usuario $userId suspendido por $days días&quot;)&#10;                callback(true, &quot;Usuario suspendido por $days días&quot;)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error suspendiendo usuario $userId: ${e.message}&quot;, e)&#10;                callback(false, &quot;Error al suspender usuario: ${e.message}&quot;)&#10;            }&#10;    }&#10;&#10;    /**&#10;     * ADMIN: Remueve la suspensión de un usuario&#10;     */&#10;    fun removeSuspension(userId: String, callback: (Boolean, String) -&gt; Unit) {&#10;        val updates = mapOf&lt;String, Any&gt;(&#10;            &quot;suspended&quot; to false,&#10;            // eliminar el campo suspensionEnd en lugar de asignar null&#10;            &quot;suspensionEnd&quot; to FieldValue.delete()&#10;        )&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#10;            .update(updates)&#10;            .addOnSuccessListener {&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Suspensión removida para usuario $userId&quot;)&#10;                callback(true, &quot;Suspensión removida exitosamente&quot;)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error removiendo suspensión $userId: ${e.message}&quot;, e)&#10;                callback(false, &quot;Error al remover suspensión: ${e.message}&quot;)&#10;            }&#10;    }&#10;&#10;    /**&#10;     * ADMIN: Elimina un usuario de la colección 'usuarios'&#10;     */&#10;    fun deleteUser(userId: String, callback: (Boolean, String) -&gt; Unit) {&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#10;            .delete()&#10;            .addOnSuccessListener {&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Usuario $userId eliminado de Firestore&quot;)&#10;                callback(true, &quot;Usuario eliminado exitosamente&quot;)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error eliminando usuario $userId: ${e.message}&quot;, e)&#10;                callback(false, &quot;Error al eliminar usuario: ${e.message}&quot;)&#10;            }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.myapplication.cloud&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.net.Uri&#13;&#10;import android.util.Base64&#13;&#10;import android.util.Log&#13;&#10;import com.example.myapplication.model.UsuarioEntity&#13;&#10;import com.google.firebase.FirebaseApp&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import com.google.firebase.firestore.ListenerRegistration&#13;&#10;import com.google.firebase.Timestamp&#13;&#10;import com.google.firebase.firestore.FieldValue&#13;&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#13;&#10;import kotlin.coroutines.resume&#13;&#10;import java.io.ByteArrayOutputStream&#13;&#10;import java.io.InputStream&#13;&#10;&#13;&#10;object FirebaseService {&#13;&#10;    // Instancia de Firestore&#13;&#10;    private val db: FirebaseFirestore&#13;&#10;        get() = FirebaseFirestore.getInstance()&#13;&#10;&#13;&#10;    // --- Estado para panel admin en realtime ---&#13;&#10;    private var adminUsersListener: ListenerRegistration? = null&#13;&#10;    private var adminProfilesListener: ListenerRegistration? = null&#13;&#10;    private val adminUsersMap = mutableMapOf&lt;String, MutableMap&lt;String, Any&gt;&gt;()&#13;&#10;    private val adminProfilesMap = mutableMapOf&lt;String, Map&lt;String, Any&gt;&gt;()&#13;&#10;    private var adminCallback: ((List&lt;Map&lt;String, Any&gt;&gt;) -&gt; Unit)? = null&#13;&#10;&#13;&#10;    // Fusiona users + profiles y notifica al callback&#13;&#10;    private fun mergeAndNotifyAdmin() {&#13;&#10;        try {&#13;&#10;            val merged = adminUsersMap.values.map { u -&gt;&#13;&#10;                val mergedMap = u.toMutableMap()&#13;&#10;                val email = u[&quot;email&quot;]?.toString() ?: &quot;&quot;&#13;&#10;                val docIdFromEmail = sanitizeDocId(email)&#13;&#10;                val profileKey = docIdFromEmail ?: (u[&quot;firebaseDocId&quot;]?.toString())&#13;&#10;                val profile = profileKey?.let { adminProfilesMap[it] }&#13;&#10;&#13;&#10;                if (profile != null &amp;&amp; profile.isNotEmpty()) {&#13;&#10;                    profile[&quot;name&quot;]?.let { if (it.toString().isNotEmpty()) mergedMap[&quot;name&quot;] = it }&#13;&#10;                    profile[&quot;photo&quot;]?.let { if (it.toString().isNotEmpty()) mergedMap[&quot;photo&quot;] = it }&#13;&#10;                    profile[&quot;city&quot;]?.let { if (it.toString().isNotEmpty()) mergedMap[&quot;city&quot;] = it }&#13;&#10;                    profile[&quot;description&quot;]?.let { if (it.toString().isNotEmpty()) mergedMap[&quot;description&quot;] = it }&#13;&#10;                }&#13;&#10;&#13;&#10;                // Campos mínimos&#13;&#10;                if (!mergedMap.containsKey(&quot;name&quot;)) mergedMap[&quot;name&quot;] = &quot;&quot;&#13;&#10;                if (!mergedMap.containsKey(&quot;email&quot;)) mergedMap[&quot;email&quot;] = &quot;&quot;&#13;&#10;                if (!mergedMap.containsKey(&quot;photo&quot;)) mergedMap[&quot;photo&quot;] = &quot;&quot;&#13;&#10;                if (!mergedMap.containsKey(&quot;blocked&quot;)) mergedMap[&quot;blocked&quot;] = false&#13;&#10;                if (!mergedMap.containsKey(&quot;suspended&quot;)) mergedMap[&quot;suspended&quot;] = false&#13;&#10;                if (!mergedMap.containsKey(&quot;posts&quot;)) mergedMap[&quot;posts&quot;] = 0&#13;&#10;                if (!mergedMap.containsKey(&quot;joinDate&quot;)) mergedMap[&quot;joinDate&quot;] = &quot;&quot;&#13;&#10;                if (!mergedMap.containsKey(&quot;lastLogin&quot;)) mergedMap[&quot;lastLogin&quot;] = &quot;&quot;&#13;&#10;&#13;&#10;                mergedMap.toMap()&#13;&#10;            }&#13;&#10;&#13;&#10;            Log.d(&quot;FirebaseService&quot;, &quot;Notificando merged users: ${merged.size}&quot;)&#13;&#10;            adminCallback?.invoke(merged)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error al mergear usuarios y profiles: ${e.message}&quot;, e)&#13;&#10;            adminCallback?.invoke(emptyList())&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ADMIN: Suscribe en tiempo real a 'usuarios' y 'userProfiles' y llama callback con la lista fusionada.&#13;&#10;     * Si ya hay listeners activos, sólo reemplaza el callback y notifica con el estado actual.&#13;&#10;     */&#13;&#10;    fun loadAllUsersForAdmin(callback: (List&lt;Map&lt;String, Any&gt;&gt;) -&gt; Unit) {&#13;&#10;        adminCallback = callback&#13;&#10;&#13;&#10;        // Si ya están los listeners, notificar inmediatamente&#13;&#10;        if (adminUsersListener != null || adminProfilesListener != null) {&#13;&#10;            mergeAndNotifyAdmin()&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        adminUsersListener = db.collection(&quot;usuarios&quot;)&#13;&#10;            .addSnapshotListener { snapshot, e -&gt;&#13;&#10;                if (e != null) {&#13;&#10;                    Log.e(&quot;FirebaseService&quot;, &quot;Error al escuchar 'usuarios': ${e.message}&quot;, e)&#13;&#10;                    return@addSnapshotListener&#13;&#10;                }&#13;&#10;&#13;&#10;                if (snapshot != null) {&#13;&#10;                    for (docChange in snapshot.documentChanges) {&#13;&#10;                        val doc = docChange.document&#13;&#10;                        val docId = doc.id&#13;&#10;                        val data = doc.data&#13;&#10;&#13;&#10;                        when (docChange.type) {&#13;&#10;                            com.google.firebase.firestore.DocumentChange.Type.ADDED,&#13;&#10;                            com.google.firebase.firestore.DocumentChange.Type.MODIFIED -&gt; {&#13;&#10;                                if (data != null) {&#13;&#10;                                    adminUsersMap[docId] = data.toMutableMap()&#13;&#10;                                    adminUsersMap[docId]?.put(&quot;firebaseDocId&quot;, docId)&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            com.google.firebase.firestore.DocumentChange.Type.REMOVED -&gt; {&#13;&#10;                                adminUsersMap.remove(docId)&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                    mergeAndNotifyAdmin()&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;        adminProfilesListener = db.collection(&quot;userProfiles&quot;)&#13;&#10;            .addSnapshotListener { snapshot, e -&gt;&#13;&#10;                if (e != null) {&#13;&#10;                    Log.e(&quot;FirebaseService&quot;, &quot;Error al escuchar 'userProfiles': ${e.message}&quot;, e)&#13;&#10;                    return@addSnapshotListener&#13;&#10;                }&#13;&#10;&#13;&#10;                if (snapshot != null) {&#13;&#10;                    for (docChange in snapshot.documentChanges) {&#13;&#10;                        val doc = docChange.document&#13;&#10;                        val docId = doc.id&#13;&#10;                        val data = doc.data&#13;&#10;&#13;&#10;                        when (docChange.type) {&#13;&#10;                            com.google.firebase.firestore.DocumentChange.Type.ADDED,&#13;&#10;                            com.google.firebase.firestore.DocumentChange.Type.MODIFIED -&gt; {&#13;&#10;                                if (data != null) adminProfilesMap[docId] = data&#13;&#10;                            }&#13;&#10;                            com.google.firebase.firestore.DocumentChange.Type.REMOVED -&gt; {&#13;&#10;                                adminProfilesMap.remove(docId)&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                    mergeAndNotifyAdmin()&#13;&#10;                }&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Detiene listeners del admin y limpia el estado.&#13;&#10;     */&#13;&#10;    fun stopAdminListeners() {&#13;&#10;        try { adminUsersListener?.remove() } catch (_: Exception) {}&#13;&#10;        adminUsersListener = null&#13;&#10;        try { adminProfilesListener?.remove() } catch (_: Exception) {}&#13;&#10;        adminProfilesListener = null&#13;&#10;        adminUsersMap.clear()&#13;&#10;        adminProfilesMap.clear()&#13;&#10;        adminCallback = null&#13;&#10;    }&#13;&#10;&#13;&#10;    // ------------------ Resto de utilidades del servicio ------------------&#13;&#10;&#13;&#10;    private fun getStorageBucketUrl(): String {&#13;&#10;        return try {&#13;&#10;            val cfg = FirebaseApp.getInstance().options.storageBucket&#13;&#10;            if (!cfg.isNullOrEmpty()) {&#13;&#10;                var bucket = cfg&#13;&#10;                if (bucket.endsWith(&quot;firebasestorage.app&quot;)) bucket = bucket.replace(&quot;firebasestorage.app&quot;, &quot;appspot.com&quot;)&#13;&#10;                if (!bucket.startsWith(&quot;gs://&quot;)) bucket = &quot;gs://$bucket&quot;&#13;&#10;                bucket&#13;&#10;            } else {&#13;&#10;                &quot;gs://tamats-aea71.appspot.com&quot;&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.w(&quot;FirebaseService&quot;, &quot;Error leyendo storageBucket: ${e.message}&quot;)&#13;&#10;            &quot;gs://tamats-aea71.appspot.com&quot;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun guardarUsuario(usuario: UsuarioEntity) {&#13;&#10;        if (esContrasenaPlana(usuario.passwordHash)) {&#13;&#10;            Log.e(&quot;FirebaseService&quot;, &quot;ERROR: Contraseña sin cifrar. Use EncryptionUtil.encryptPassword().&quot;)&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        val data = mapOf(&#13;&#10;            &quot;name&quot; to usuario.name,&#13;&#10;            &quot;email&quot; to usuario.email,&#13;&#10;            &quot;birthDate&quot; to usuario.birthDate,&#13;&#10;            &quot;gender&quot; to usuario.gender,&#13;&#10;            &quot;passwordHash&quot; to usuario.passwordHash,&#13;&#10;            &quot;blocked&quot; to false,&#13;&#10;            &quot;suspended&quot; to false,&#13;&#10;            &quot;suspensionEnd&quot; to null,&#13;&#10;            &quot;posts&quot; to 0,&#13;&#10;            &quot;photo&quot; to &quot;&quot;,&#13;&#10;            &quot;joinDate&quot; to Timestamp.now(),&#13;&#10;            &quot;lastLogin&quot; to Timestamp.now()&#13;&#10;        )&#13;&#10;&#13;&#10;        val docId = usuario.email.replace(Regex(&quot;[^a-zA-Z0-9._-]&quot;), &quot;_&quot;)&#13;&#10;        db.collection(&quot;usuarios&quot;).document(docId).set(data)&#13;&#10;            .addOnSuccessListener { Log.d(&quot;FirebaseService&quot;, &quot;Usuario guardado: $docId&quot;) }&#13;&#10;            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;, &quot;Error guardando usuario: ${e.message}&quot;, e) }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun esContrasenaPlana(passwordHash: String): Boolean {&#13;&#10;        return passwordHash.length == 8 &amp;&amp; passwordHash.matches(Regex(&quot;[a-zA-Z0-9]*&quot;))&#13;&#10;    }&#13;&#10;&#13;&#10;    fun obtenerUsuarios(callback: (List&lt;UsuarioEntity&gt;) -&gt; Unit) {&#13;&#10;        db.collection(&quot;usuarios&quot;).get()&#13;&#10;            .addOnSuccessListener { result -&gt;&#13;&#10;                val lista = result.map { doc -&gt;&#13;&#10;                    UsuarioEntity(&#13;&#10;                        id = 0,&#13;&#10;                        name = doc.getString(&quot;name&quot;) ?: &quot;&quot;,&#13;&#10;                        email = doc.getString(&quot;email&quot;) ?: &quot;&quot;,&#13;&#10;                        birthDate = doc.getString(&quot;birthDate&quot;) ?: &quot;&quot;,&#13;&#10;                        gender = doc.getString(&quot;gender&quot;) ?: &quot;&quot;,&#13;&#10;                        passwordHash = doc.getString(&quot;passwordHash&quot;) ?: &quot;&quot;&#13;&#10;                    )&#13;&#10;                }&#13;&#10;                callback(lista)&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error al obtener usuarios: ${e.message}&quot;, e)&#13;&#10;                callback(emptyList())&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun findUserByEmail(email: String, callback: (UsuarioEntity?) -&gt; Unit) {&#13;&#10;        db.collection(&quot;usuarios&quot;).whereEqualTo(&quot;email&quot;, email).limit(1).get()&#13;&#10;            .addOnSuccessListener { documents -&gt;&#13;&#10;                if (!documents.isEmpty) {&#13;&#10;                    val doc = documents.first()&#13;&#10;                    val user = UsuarioEntity(&#13;&#10;                        id = 0,&#13;&#10;                        name = doc.getString(&quot;name&quot;) ?: &quot;&quot;,&#13;&#10;                        email = doc.getString(&quot;email&quot;) ?: &quot;&quot;,&#13;&#10;                        birthDate = doc.getString(&quot;birthDate&quot;) ?: &quot;&quot;,&#13;&#10;                        gender = doc.getString(&quot;gender&quot;) ?: &quot;&quot;,&#13;&#10;                        passwordHash = doc.getString(&quot;passwordHash&quot;) ?: &quot;&quot;&#13;&#10;                    )&#13;&#10;                    callback(user)&#13;&#10;                } else {&#13;&#10;                    val docId = email.replace(Regex(&quot;[^a-zA-Z0-9._-]&quot;), &quot;_&quot;)&#13;&#10;                    db.collection(&quot;usuarios&quot;).document(docId).get()&#13;&#10;                        .addOnSuccessListener { doc -&gt;&#13;&#10;                            if (doc.exists()) {&#13;&#10;                                val user = UsuarioEntity(&#13;&#10;                                    id = 0,&#13;&#10;                                    name = doc.getString(&quot;name&quot;) ?: &quot;&quot;,&#13;&#10;                                    email = doc.getString(&quot;email&quot;) ?: &quot;&quot;,&#13;&#10;                                    birthDate = doc.getString(&quot;birthDate&quot;) ?: &quot;&quot;,&#13;&#10;                                    gender = doc.getString(&quot;gender&quot;) ?: &quot;&quot;,&#13;&#10;                                    passwordHash = doc.getString(&quot;passwordHash&quot;) ?: &quot;&quot;&#13;&#10;                                )&#13;&#10;                                callback(user)&#13;&#10;                            } else callback(null)&#13;&#10;                        }&#13;&#10;                        .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;, &quot;Error buscando por ID: ${e.message}&quot;, e); callback(null) }&#13;&#10;                }&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;, &quot;Error buscando por email: ${e.message}&quot;, e); callback(null) }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Suppress(&quot;unused&quot;)&#13;&#10;    fun uploadImage(uri: Uri, context: Context, callback: (String?) -&gt; Unit) {&#13;&#10;        try {&#13;&#10;            val base64 = uriToBase64(context, uri)&#13;&#10;            callback(base64)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error uploadImage: ${e.message}&quot;, e)&#13;&#10;            callback(null)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Suppress(&quot;unused&quot;)&#13;&#10;    suspend fun uploadImageSuspend(uri: Uri, context: Context): String? = suspendCancellableCoroutine { cont -&gt;&#13;&#10;        try {&#13;&#10;            val b64 = uriToBase64(context, uri)&#13;&#10;            if (cont.isActive) cont.resume(b64)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            if (cont.isActive) cont.resume(null)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun uriToBase64(context: Context, uri: Uri, maxBytes: Int = 900 * 1024): String? {&#13;&#10;        var input: InputStream? = null&#13;&#10;        try {&#13;&#10;            input = context.contentResolver.openInputStream(uri) ?: return null&#13;&#10;            val buffer = ByteArray(8192)&#13;&#10;            val baos = ByteArrayOutputStream()&#13;&#10;            var read: Int&#13;&#10;            while (true) {&#13;&#10;                read = input.read(buffer)&#13;&#10;                if (read &lt;= 0) break&#13;&#10;                baos.write(buffer, 0, read)&#13;&#10;            }&#13;&#10;            val rawBytes = baos.toByteArray()&#13;&#10;            val directB64 = Base64.encodeToString(rawBytes, Base64.NO_WRAP)&#13;&#10;            if (directB64.toByteArray(Charsets.UTF_8).size &lt;= maxBytes) return directB64&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.w(&quot;FirebaseService&quot;, &quot;Lectura directa falló: ${e.message}&quot;)&#13;&#10;        } finally {&#13;&#10;            try { input?.close() } catch (_: Exception) {}&#13;&#10;        }&#13;&#10;&#13;&#10;        // Intentar con Bitmap y compresión (omito detalles para mantener legible)&#13;&#10;        try {&#13;&#10;            var bitmapInput: InputStream? = null&#13;&#10;            val optionsBounds = android.graphics.BitmapFactory.Options()&#13;&#10;            optionsBounds.inJustDecodeBounds = true&#13;&#10;            bitmapInput = context.contentResolver.openInputStream(uri) ?: return null&#13;&#10;            android.graphics.BitmapFactory.decodeStream(bitmapInput, null, optionsBounds)&#13;&#10;            bitmapInput.close()&#13;&#10;&#13;&#10;            var sampleSize = 1&#13;&#10;            val desiredMaxDim = 1280&#13;&#10;            val width = optionsBounds.outWidth&#13;&#10;            val height = optionsBounds.outHeight&#13;&#10;            if (width &gt; desiredMaxDim || height &gt; desiredMaxDim) {&#13;&#10;                val scale = Math.max(width / desiredMaxDim, height / desiredMaxDim)&#13;&#10;                var s = 1&#13;&#10;                while (s &lt; scale) s *= 2&#13;&#10;                sampleSize = s&#13;&#10;            }&#13;&#10;&#13;&#10;            val optionsDecode = android.graphics.BitmapFactory.Options()&#13;&#10;            optionsDecode.inSampleSize = sampleSize&#13;&#10;            bitmapInput = context.contentResolver.openInputStream(uri) ?: return null&#13;&#10;            val bmp = android.graphics.BitmapFactory.decodeStream(bitmapInput, null, optionsDecode)&#13;&#10;            bitmapInput.close()&#13;&#10;            if (bmp == null) return null&#13;&#10;&#13;&#10;            val baos2 = ByteArrayOutputStream()&#13;&#10;            var quality = 85&#13;&#10;            while (quality &gt;= 30) {&#13;&#10;                baos2.reset()&#13;&#10;                bmp.compress(android.graphics.Bitmap.CompressFormat.JPEG, quality, baos2)&#13;&#10;                val compressed = baos2.toByteArray()&#13;&#10;                val b64 = Base64.encodeToString(compressed, Base64.NO_WRAP)&#13;&#10;                if (b64.toByteArray(Charsets.UTF_8).size &lt;= maxBytes) return b64&#13;&#10;                quality -= 10&#13;&#10;            }&#13;&#10;&#13;&#10;            // Si no entra, reducir dimensiones iterativamente&#13;&#10;            var currentWidth = bmp.width&#13;&#10;            var currentHeight = bmp.height&#13;&#10;            var reducedBmp: android.graphics.Bitmap? = bmp&#13;&#10;            while (true) {&#13;&#10;                val newW = (currentWidth * 0.75).toInt().coerceAtLeast(100)&#13;&#10;                val newH = (currentHeight * 0.75).toInt().coerceAtLeast(100)&#13;&#10;                if (newW &gt;= currentWidth || newH &gt;= currentHeight) break&#13;&#10;                val scaled = android.graphics.Bitmap.createScaledBitmap(reducedBmp!!, newW, newH, true)&#13;&#10;                if (reducedBmp !== bmp) try { reducedBmp.recycle() } catch (_: Exception) {}&#13;&#10;                reducedBmp = scaled&#13;&#10;                currentWidth = reducedBmp.width&#13;&#10;                currentHeight = reducedBmp.height&#13;&#10;&#13;&#10;                baos2.reset()&#13;&#10;                reducedBmp.compress(android.graphics.Bitmap.CompressFormat.JPEG, 70, baos2)&#13;&#10;                val compressed = baos2.toByteArray()&#13;&#10;                val b64try = Base64.encodeToString(compressed, Base64.NO_WRAP)&#13;&#10;                if (b64try.toByteArray(Charsets.UTF_8).size &lt;= maxBytes) return b64try&#13;&#10;                if (currentWidth &lt;= 200 || currentHeight &lt;= 200) break&#13;&#10;            }&#13;&#10;&#13;&#10;            return null&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error procesando bitmap: ${e.message}&quot;, e)&#13;&#10;            return null&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun sanitizeDocId(id: String?): String? {&#13;&#10;        if (id.isNullOrBlank()) return null&#13;&#10;        return id.replace(&quot;/&quot;, &quot;_&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun saveUserProfile(email: String, profileData: Map&lt;String, Any&gt;, callback: (Boolean) -&gt; Unit) {&#13;&#10;        db.collection(&quot;usuarios&quot;).whereEqualTo(&quot;email&quot;, email).limit(1).get()&#13;&#10;            .addOnSuccessListener { documents -&gt;&#13;&#10;                if (documents.isEmpty) {&#13;&#10;                    val docId = sanitizeDocId(email)&#13;&#10;                    if (docId != null) {&#13;&#10;                        db.collection(&quot;userProfiles&quot;).document(docId).set(profileData)&#13;&#10;                            .addOnSuccessListener { callback(true) }&#13;&#10;                            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error saveUserProfile: ${e.message}&quot;, e); callback(false) }&#13;&#10;                    } else {&#13;&#10;                        db.collection(&quot;userProfiles&quot;).add(profileData)&#13;&#10;                            .addOnSuccessListener { callback(true) }&#13;&#10;                            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error saveUserProfile auto-id: ${e.message}&quot;, e); callback(false) }&#13;&#10;                    }&#13;&#10;                } else {&#13;&#10;                    val doc = documents.first()&#13;&#10;                    val existingId = doc.id&#13;&#10;                    val existingCollection = doc.reference.parent.id&#13;&#10;                    val updates = profileData.mapValues { it.value as Any }&#13;&#10;                    db.collection(existingCollection).document(existingId)&#13;&#10;                        .update(updates)&#13;&#10;                        .addOnSuccessListener { callback(true) }&#13;&#10;                        .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error update profile: ${e.message}&quot;, e); callback(false) }&#13;&#10;                }&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error finding user for saveUserProfile: ${e.message}&quot;, e); callback(false) }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getUserProfile(email: String, callback: (Map&lt;String, Any&gt;?) -&gt; Unit) {&#13;&#10;        val docId = sanitizeDocId(email)&#13;&#10;        if (docId != null) {&#13;&#10;            db.collection(&quot;userProfiles&quot;).document(docId).get()&#13;&#10;                .addOnSuccessListener { document -&gt;&#13;&#10;                    if (document.exists()) callback(document.data) else {&#13;&#10;                        db.collection(&quot;usuarios&quot;).whereEqualTo(&quot;email&quot;, email).limit(1).get()&#13;&#10;                            .addOnSuccessListener { docs -&gt; if (!docs.isEmpty) callback(docs.first().data) else callback(null) }&#13;&#10;                            .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error getUserProfile usuarios: ${e.message}&quot;, e); callback(null) }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error getUserProfile userProfiles: ${e.message}&quot;, e); callback(null) }&#13;&#10;        } else {&#13;&#10;            db.collection(&quot;usuarios&quot;).whereEqualTo(&quot;email&quot;, email).limit(1).get()&#13;&#10;                .addOnSuccessListener { docs -&gt; if (!docs.isEmpty) callback(docs.first().data) else callback(null) }&#13;&#10;                .addOnFailureListener { e -&gt; Log.e(&quot;FirebaseService&quot;,&quot;Error getUserProfile usuarios fallback: ${e.message}&quot;, e); callback(null) }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getCurrentUserEmail(): String {&#13;&#10;        return try {&#13;&#10;            val auth = FirebaseAuth.getInstance()&#13;&#10;            auth.currentUser?.email ?: &quot;&quot;&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error obteniendo email: ${e.message}&quot;, e)&#13;&#10;            &quot;&quot;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun logout(context: Context? = null) {&#13;&#10;        try {&#13;&#10;            FirebaseAuth.getInstance().signOut()&#13;&#10;            context?.let {&#13;&#10;                val prefs = it.getSharedPreferences(&quot;user_data&quot;, Context.MODE_PRIVATE)&#13;&#10;                prefs.edit().clear().apply()&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;FirebaseService&quot;, &quot;Error logout: ${e.message}&quot;, e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ADMIN: Bloquea un usuario (marca blocked = true, suspended = false)&#13;&#10;     */&#13;&#10;    fun blockUser(userId: String, callback: (Boolean, String) -&gt; Unit) {&#13;&#10;        val updates = mapOf&lt;String, Any&gt;(&#13;&#10;            &quot;blocked&quot; to true,&#13;&#10;            &quot;suspended&quot; to false,&#13;&#10;            // eliminar el campo suspensionEnd si existía&#13;&#10;            &quot;suspensionEnd&quot; to FieldValue.delete()&#13;&#10;        )&#13;&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#13;&#10;            .update(updates)&#13;&#10;            .addOnSuccessListener {&#13;&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Usuario $userId bloqueado en Firestore&quot;)&#13;&#10;                callback(true, &quot;Usuario bloqueado exitosamente&quot;)&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error bloqueando usuario $userId: ${e.message}&quot;, e)&#13;&#10;                callback(false, &quot;Error al bloquear usuario: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ADMIN: Desbloquea un usuario (marca blocked = false)&#13;&#10;     */&#13;&#10;    fun unblockUser(userId: String, callback: (Boolean, String) -&gt; Unit) {&#13;&#10;        val updates = mapOf&lt;String, Any&gt;(&quot;blocked&quot; to false)&#13;&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#13;&#10;            .update(updates)&#13;&#10;            .addOnSuccessListener {&#13;&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Usuario $userId desbloqueado en Firestore&quot;)&#13;&#10;                callback(true, &quot;Usuario desbloqueado exitosamente&quot;)&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error desbloqueando usuario $userId: ${e.message}&quot;, e)&#13;&#10;                callback(false, &quot;Error al desbloquear usuario: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ADMIN: Suspende un usuario por X días (marca suspended = true y suspensionEnd en millis)&#13;&#10;     */&#13;&#10;    fun suspendUser(userId: String, days: Int, callback: (Boolean, String) -&gt; Unit) {&#13;&#10;        val suspensionEnd = System.currentTimeMillis() + (days * 24L * 60L * 60L * 1000L)&#13;&#10;        val updates = mapOf&lt;String, Any&gt;(&#13;&#10;            &quot;suspended&quot; to true,&#13;&#10;            &quot;suspensionEnd&quot; to suspensionEnd,&#13;&#10;            &quot;blocked&quot; to false&#13;&#10;        )&#13;&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#13;&#10;            .update(updates)&#13;&#10;            .addOnSuccessListener {&#13;&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Usuario $userId suspendido por $days días&quot;)&#13;&#10;                callback(true, &quot;Usuario suspendido por $days días&quot;)&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error suspendiendo usuario $userId: ${e.message}&quot;, e)&#13;&#10;                callback(false, &quot;Error al suspender usuario: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ADMIN: Remueve la suspensión de un usuario&#13;&#10;     */&#13;&#10;    fun removeSuspension(userId: String, callback: (Boolean, String) -&gt; Unit) {&#13;&#10;        val updates = mapOf&lt;String, Any&gt;(&#13;&#10;            &quot;suspended&quot; to false,&#13;&#10;            // eliminar el campo suspensionEnd en lugar de asignar null&#13;&#10;            &quot;suspensionEnd&quot; to FieldValue.delete()&#13;&#10;        )&#13;&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#13;&#10;            .update(updates)&#13;&#10;            .addOnSuccessListener {&#13;&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Suspensión removida para usuario $userId&quot;)&#13;&#10;                callback(true, &quot;Suspensión removida exitosamente&quot;)&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error removiendo suspensión $userId: ${e.message}&quot;, e)&#13;&#10;                callback(false, &quot;Error al remover suspensión: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ADMIN: Elimina un usuario de la colección 'usuarios'&#13;&#10;     */&#13;&#10;    fun deleteUser(userId: String, callback: (Boolean, String) -&gt; Unit) {&#13;&#10;        db.collection(&quot;usuarios&quot;).document(userId)&#13;&#10;            .delete()&#13;&#10;            .addOnSuccessListener {&#13;&#10;                Log.d(&quot;FirebaseService&quot;, &quot;Usuario $userId eliminado de Firestore&quot;)&#13;&#10;                callback(true, &quot;Usuario eliminado exitosamente&quot;)&#13;&#10;            }&#13;&#10;            .addOnFailureListener { e -&gt;&#13;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;Error eliminando usuario $userId: ${e.message}&quot;, e)&#13;&#10;                callback(false, &quot;Error al eliminar usuario: ${e.message}&quot;)&#10;            }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la contraseña de un usuario en Firebase&#10;     */&#10;    fun actualizarContrasena(email: String, newPasswordHash: String, callback: ((Boolean, String) -&gt; Unit)? = null) {&#10;        val docId = email.replace(Regex(&quot;[^a-zA-Z0-9._-]&quot;), &quot;_&quot;)&#10;        &#10;        db.collection(&quot;usuarios&quot;).document(docId)&#10;            .update(&quot;passwordHash&quot;, newPasswordHash)&#10;            .addOnSuccessListener {&#10;                Log.d(&quot;FirebaseService&quot;, &quot;✅ Contraseña actualizada para: $email&quot;)&#10;                callback?.invoke(true, &quot;Contraseña actualizada exitosamente&quot;)&#10;            }&#10;            .addOnFailureListener { e -&gt;&#10;                Log.e(&quot;FirebaseService&quot;, &quot;❌ Error actualizando contraseña: ${e.message}&quot;, e)&#10;                callback?.invoke(false, &quot;Error al actualizar contraseña: ${e.message}&quot;)&#10;            }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/dao/UsuarioDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/dao/UsuarioDao.kt" />
              <option name="originalContent" value="package com.example.myapplication.dao&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.OnConflictStrategy&#10;import androidx.room.Query&#10;import com.example.myapplication.model.UsuarioEntity&#10;&#10;@Dao&#10;interface UsuarioDao {&#10;&#10;    // 1. Insertar un nuevo usuario&#10;    // suspend: Indica que la función debe ejecutarse en un hilo secundario (Coroutines)&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertar(user: UsuarioEntity)&#10;&#10;    // 2. Consulta para Login: Obtener un usuario por email.&#10;    @Query(&quot;SELECT * FROM usuarios WHERE email = :email LIMIT 1&quot;)&#10;    suspend fun getUserByEmail(email: String): UsuarioEntity?&#10;&#10;    // 3. Consulta para verificar si un email ya existe (útil en RegisterActivity)&#10;    @Query(&quot;SELECT EXISTS(SELECT 1 FROM usuarios WHERE email = :email)&quot;)&#10;    suspend fun isEmailRegistered(email: String): Boolean&#10;}" />
              <option name="updatedContent" value="package com.example.myapplication.dao&#13;&#10;&#13;&#10;import androidx.room.Dao&#13;&#10;import androidx.room.Insert&#13;&#10;import androidx.room.OnConflictStrategy&#13;&#10;import androidx.room.Query&#13;&#10;import androidx.room.Update&#13;&#10;import com.example.myapplication.model.UsuarioEntity&#13;&#10;&#13;&#10;@Dao&#13;&#10;interface UsuarioDao {&#13;&#10;&#13;&#10;    // 1. Insertar un nuevo usuario&#13;&#10;    // suspend: Indica que la función debe ejecutarse en un hilo secundario (Coroutines)&#13;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#13;&#10;    suspend fun insertar(user: UsuarioEntity)&#13;&#10;&#13;&#10;    // Actualizar un usuario existente (para cambiar contraseña, etc.)&#13;&#10;    @Update&#13;&#10;    suspend fun actualizar(user: UsuarioEntity)&#13;&#10;&#13;&#10;    // 2. Consulta para Login: Obtener un usuario por email.&#13;&#10;    @Query(&quot;SELECT * FROM usuarios WHERE email = :email LIMIT 1&quot;)&#13;&#10;    suspend fun getUserByEmail(email: String): UsuarioEntity?&#13;&#10;&#13;&#10;    // 3. Consulta para verificar si un email ya existe (útil en RegisterActivity)&#13;&#10;    @Query(&quot;SELECT EXISTS(SELECT 1 FROM usuarios WHERE email = :email)&quot;)&#13;&#10;    suspend fun isEmailRegistered(email: String): Boolean&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/password/ResetPasswordActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/password/ResetPasswordActivity.kt" />
              <option name="updatedContent" value="package com.example.myapplication.ui.password&#10;&#10;import android.content.Intent&#10;import android.graphics.Color&#10;import android.os.Bundle&#10;import android.text.Editable&#10;import android.text.TextWatcher&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.example.myapplication.R&#10;import com.example.myapplication.database.AppDatabase&#10;import com.example.myapplication.ui.login.LoginActivity&#10;import com.example.myapplication.util.EncryptionUtil&#10;import com.example.myapplication.util.PasswordValidator&#10;import com.google.android.material.button.MaterialButton&#10;import com.google.android.material.textfield.TextInputEditText&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;&#10;class ResetPasswordActivity : AppCompatActivity() {&#10;&#10;    private lateinit var tvEmailDisplay: TextView&#10;    private lateinit var etNewPassword: TextInputEditText&#10;    private lateinit var etConfirmNewPassword: TextInputEditText&#10;    private lateinit var btnChangePassword: MaterialButton&#10;    private lateinit var tvCancelReset: TextView&#10;    &#10;    // Indicadores visuales de requisitos&#10;    private lateinit var tvReqLength: TextView&#10;    private lateinit var tvReqUppercase: TextView&#10;    private lateinit var tvReqNumber: TextView&#10;&#10;    private val db by lazy { AppDatabase.getInstance(applicationContext) }&#10;    private val usuarioDao by lazy { db.usuarioDao() }&#10;&#10;    private var email: String? = null&#10;    private var token: String? = null&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_reset_password)&#10;&#10;        // Obtener datos del Intent (desde Deep Link)&#10;        email = intent.data?.getQueryParameter(&quot;email&quot;) ?: intent.getStringExtra(&quot;email&quot;)&#10;        token = intent.data?.getQueryParameter(&quot;token&quot;) ?: intent.getStringExtra(&quot;token&quot;)&#10;&#10;        // Validar que tengamos los datos necesarios&#10;        if (email.isNullOrEmpty() || token.isNullOrEmpty()) {&#10;            Toast.makeText(this, &quot;❌ Link inválido o expirado&quot;, Toast.LENGTH_LONG).show()&#10;            finish()&#10;            return&#10;        }&#10;&#10;        // Validar que el token sea válido y no haya expirado&#10;        if (!isTokenValid(token!!)) {&#10;            Toast.makeText(&#10;                this,&#10;                &quot;❌ Este enlace ha expirado.\nSolicita uno nuevo desde 'Olvidé mi contraseña'&quot;,&#10;                Toast.LENGTH_LONG&#10;            ).show()&#10;            finish()&#10;            return&#10;        }&#10;&#10;        initializeViews()&#10;        setupListeners()&#10;        displayEmail()&#10;    }&#10;&#10;    private fun initializeViews() {&#10;        tvEmailDisplay = findViewById(R.id.tvEmailDisplay)&#10;        etNewPassword = findViewById(R.id.etNewPassword)&#10;        etConfirmNewPassword = findViewById(R.id.etConfirmNewPassword)&#10;        btnChangePassword = findViewById(R.id.btnChangePassword)&#10;        tvCancelReset = findViewById(R.id.tvCancelReset)&#10;        &#10;        tvReqLength = findViewById(R.id.tvReqLength)&#10;        tvReqUppercase = findViewById(R.id.tvReqUppercase)&#10;        tvReqNumber = findViewById(R.id.tvReqNumber)&#10;    }&#10;&#10;    private fun setupListeners() {&#10;        // Validación en tiempo real mientras escribe&#10;        etNewPassword.addTextChangedListener(object : TextWatcher {&#10;            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {}&#10;            override fun afterTextChanged(s: Editable?) {&#10;                val password = s?.toString() ?: &quot;&quot;&#10;                updatePasswordRequirements(password)&#10;            }&#10;        })&#10;&#10;        btnChangePassword.setOnClickListener {&#10;            handlePasswordChange()&#10;        }&#10;&#10;        tvCancelReset.setOnClickListener {&#10;            finish()&#10;            startActivity(Intent(this, LoginActivity::class.java))&#10;        }&#10;    }&#10;&#10;    private fun displayEmail() {&#10;        tvEmailDisplay.text = email&#10;    }&#10;&#10;    /**&#10;     * Actualiza visualmente los requisitos de contraseña&#10;     */&#10;    private fun updatePasswordRequirements(password: String) {&#10;        val validation = PasswordValidator.validate(password)&#10;        &#10;        val colorValid = ContextCompat.getColor(this, R.color.green_success)&#10;        val colorInvalid = Color.parseColor(&quot;#757575&quot;)&#10;        val iconValid = R.drawable.ic_check_circle&#10;        val iconInvalid = R.drawable.ic_circle_outline&#10;&#10;        // Longitud&#10;        tvReqLength.setTextColor(if (validation.meetsLength) colorValid else colorInvalid)&#10;        tvReqLength.setCompoundDrawablesRelativeWithIntrinsicBounds(&#10;            if (validation.meetsLength) iconValid else iconInvalid, 0, 0, 0&#10;        )&#10;&#10;        // Mayúscula&#10;        tvReqUppercase.setTextColor(if (validation.meetsUppercase) colorValid else colorInvalid)&#10;        tvReqUppercase.setCompoundDrawablesRelativeWithIntrinsicBounds(&#10;            if (validation.meetsUppercase) iconValid else iconInvalid, 0, 0, 0&#10;        )&#10;&#10;        // Número&#10;        tvReqNumber.setTextColor(if (validation.meetsNumber) colorValid else colorInvalid)&#10;        tvReqNumber.setCompoundDrawablesRelativeWithIntrinsicBounds(&#10;            if (validation.meetsNumber) iconValid else iconInvalid, 0, 0, 0&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Maneja el cambio de contraseña&#10;     */&#10;    private fun handlePasswordChange() {&#10;        val newPassword = etNewPassword.text?.toString() ?: &quot;&quot;&#10;        val confirmPassword = etConfirmNewPassword.text?.toString() ?: &quot;&quot;&#10;&#10;        // Limpiar errores previos&#10;        etNewPassword.error = null&#10;        etConfirmNewPassword.error = null&#10;&#10;        // Validar contraseña&#10;        val validation = PasswordValidator.validate(newPassword)&#10;        if (!validation.isValid) {&#10;            etNewPassword.error = PasswordValidator.getErrorMessage(validation)&#10;            Toast.makeText(this, &quot;❌ La contraseña no cumple los requisitos&quot;, Toast.LENGTH_LONG).show()&#10;            return&#10;        }&#10;&#10;        // Verificar que coincidan&#10;        if (!PasswordValidator.passwordsMatch(newPassword, confirmPassword)) {&#10;            etConfirmNewPassword.error = &quot;Las contraseñas no coinciden&quot;&#10;            Toast.makeText(this, &quot;❌ Las contraseñas no coinciden&quot;, Toast.LENGTH_LONG).show()&#10;            return&#10;        }&#10;&#10;        // Deshabilitar botón mientras se procesa&#10;        btnChangePassword.isEnabled = false&#10;        btnChangePassword.text = &quot;Actualizando...&quot;&#10;&#10;        // Actualizar contraseña en la base de datos&#10;        lifecycleScope.launch(Dispatchers.IO) {&#10;            try {&#10;                val user = usuarioDao.getUserByEmail(email!!)&#10;                &#10;                if (user == null) {&#10;                    withContext(Dispatchers.Main) {&#10;                        Toast.makeText(&#10;                            this@ResetPasswordActivity,&#10;                            &quot;❌ Usuario no encontrado&quot;,&#10;                            Toast.LENGTH_LONG&#10;                        ).show()&#10;                        btnChangePassword.isEnabled = true&#10;                        btnChangePassword.text = &quot;Cambiar Contraseña&quot;&#10;                    }&#10;                    return@launch&#10;                }&#10;&#10;                // Cifrar nueva contraseña&#10;                val encryptedPassword = EncryptionUtil.encryptPassword(newPassword)&#10;                &#10;                // Actualizar contraseña en Room&#10;                val updatedUser = user.copy(passwordHash = encryptedPassword)&#10;                usuarioDao.actualizar(updatedUser)&#10;                &#10;                // También actualizar en Firebase (opcional pero recomendado)&#10;                com.example.myapplication.cloud.FirebaseService.actualizarContrasena(email!!, encryptedPassword)&#10;                &#10;                // Invalidar el token usado&#10;                invalidateToken(token!!)&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    // Mostrar diálogo de éxito&#10;                    showSuccessDialog()&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                withContext(Dispatchers.Main) {&#10;                    Toast.makeText(&#10;                        this@ResetPasswordActivity,&#10;                        &quot;❌ Error al actualizar contraseña: ${e.message}&quot;,&#10;                        Toast.LENGTH_LONG&#10;                    ).show()&#10;                    btnChangePassword.isEnabled = true&#10;                    btnChangePassword.text = &quot;Cambiar Contraseña&quot;&#10;                    android.util.Log.e(&quot;ResetPassword&quot;, &quot;Error: ${e.message}&quot;, e)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica que el token sea válido y no haya expirado&#10;     */&#10;    private fun isTokenValid(token: String): Boolean {&#10;        val prefs = getSharedPreferences(&quot;password_reset&quot;, MODE_PRIVATE)&#10;        val savedEmail = prefs.getString(&quot;token_$token&quot;, null)&#10;        val timestamp = prefs.getLong(&quot;timestamp_$token&quot;, 0)&#10;&#10;        // Verificar que el token existe y coincide con el email&#10;        if (savedEmail != email) {&#10;            android.util.Log.w(&quot;ResetPassword&quot;, &quot;Token no coincide con email&quot;)&#10;            return false&#10;        }&#10;&#10;        // Verificar que no haya expirado (1 hora = 3600000 ms)&#10;        val oneHour = 3600000L&#10;        val isExpired = (System.currentTimeMillis() - timestamp) &gt; oneHour&#10;&#10;        if (isExpired) {&#10;            android.util.Log.w(&quot;ResetPassword&quot;, &quot;Token expirado&quot;)&#10;        }&#10;&#10;        return !isExpired&#10;    }&#10;&#10;    /**&#10;     * Invalida el token después de usarlo&#10;     */&#10;    private fun invalidateToken(token: String) {&#10;        val prefs = getSharedPreferences(&quot;password_reset&quot;, MODE_PRIVATE)&#10;        prefs.edit().apply {&#10;            remove(&quot;token_$token&quot;)&#10;            remove(&quot;timestamp_$token&quot;)&#10;            apply()&#10;        }&#10;        android.util.Log.d(&quot;ResetPassword&quot;, &quot;Token invalidado: $token&quot;)&#10;    }&#10;&#10;    /**&#10;     * Muestra diálogo de éxito y redirige al login&#10;     */&#10;    private fun showSuccessDialog() {&#10;        val builder = androidx.appcompat.app.AlertDialog.Builder(this)&#10;        builder.setTitle(&quot;✅ Contraseña Actualizada&quot;)&#10;        builder.setMessage(&quot;Tu contraseña ha sido actualizada exitosamente.\n\n¡Ya puedes iniciar sesión con tu nueva contraseña!&quot;)&#10;        builder.setPositiveButton(&quot;Ir al Login&quot;) { dialog, _ -&gt;&#10;            dialog.dismiss()&#10;            navigateToLogin()&#10;        }&#10;        builder.setCancelable(false)&#10;        builder.show()&#10;    }&#10;&#10;    /**&#10;     * Redirige al login limpiando el stack de actividades&#10;     */&#10;    private fun navigateToLogin() {&#10;        val intent = Intent(this, LoginActivity::class.java)&#10;        intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onBackPressed() {&#10;        // Prevenir volver atrás, solo permitir ir al login&#10;        navigateToLogin()&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/register/RegisterActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/ui/register/RegisterActivity.kt" />
              <option name="originalContent" value="package com.example.myapplication.ui.register&#10;&#10;import android.app.DatePickerDialog&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.text.InputFilter&#10;import android.widget.*&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.example.myapplication.R&#10;import com.example.myapplication.cloud.FirebaseService&#10;import com.example.myapplication.database.AppDatabase&#10;import com.example.myapplication.model.UsuarioEntity&#10;import com.example.myapplication.ui.login.LoginActivity&#10;import com.example.myapplication.util.EncryptionUtil&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.util.*&#10;&#10;class RegisterActivity : AppCompatActivity() {&#10;&#10;    // Declaración de variables de la UI&#10;    private lateinit var etName: EditText&#10;    private lateinit var etEmailRegister: EditText&#10;    private lateinit var etBirthDate: EditText&#10;    private lateinit var spinnerGender: Spinner&#10;    private lateinit var etPasswordRegister: EditText&#10;    private lateinit var etConfirmPassword: EditText&#10;    private lateinit var cbTerms: CheckBox&#10;    private lateinit var btnRegister: Button&#10;    private lateinit var tvLoginLink: TextView&#10;    private lateinit var tvViewTerms: TextView&#10;&#10;    private val db by lazy { AppDatabase.getInstance(applicationContext) }&#10;    private val usuarioDao by lazy { db.usuarioDao() }&#10;    private val firebaseService by lazy { FirebaseService }&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private val emailRegex = Regex(&quot;[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+&quot;)&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_register)&#10;&#10;        // Inicialización de Vistas&#10;        etName = findViewById(R.id.etName)&#10;        etEmailRegister = findViewById(R.id.etEmailRegister)&#10;        etBirthDate = findViewById(R.id.etBirthDate)&#10;        spinnerGender = findViewById(R.id.spinnerGender)&#10;        etPasswordRegister = findViewById(R.id.etPasswordRegister)&#10;        etConfirmPassword = findViewById(R.id.etConfirmPassword)&#10;        cbTerms = findViewById(R.id.cbTerms)&#10;        btnRegister = findViewById(R.id.btnRegister)&#10;        tvLoginLink = findViewById(R.id.tvLoginLink)&#10;        tvViewTerms = findViewById(R.id.tvViewTerms)&#10;&#10;        setupListeners()&#10;    }&#10;&#10;    private fun setupListeners() {&#10;        etName.filters = arrayOf(InputFilter { source, _, _, _, _, _ -&gt;&#10;            if (source.toString().matches(Regex(&quot;[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]*&quot;))) source else &quot;&quot;&#10;        })&#10;&#10;        etBirthDate.setOnClickListener { showDatePickerDialog() }&#10;&#10;        btnRegister.setOnClickListener { handleRegistration() }&#10;&#10;        tvLoginLink.setOnClickListener {&#10;            val intent = Intent(this, LoginActivity::class.java)&#10;            startActivity(intent)&#10;            finish()&#10;        }&#10;&#10;        tvViewTerms.setOnClickListener {&#10;            val intent = Intent(this, TermsAndConditionsActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;    }&#10;&#10;    private fun showDatePickerDialog() {&#10;        val calendar = Calendar.getInstance()&#10;        val year = calendar.get(Calendar.YEAR)&#10;        val month = calendar.get(Calendar.MONTH)&#10;        val day = calendar.get(Calendar.DAY_OF_MONTH)&#10;&#10;        val datePickerDialog = DatePickerDialog(&#10;            this,&#10;            { _, selectedYear, selectedMonth, selectedDay -&gt;&#10;                val date = &quot;${selectedDay.toString().padStart(2, '0')}/${(selectedMonth + 1).toString().padStart(2, '0')}/${selectedYear}&quot;&#10;                etBirthDate.setText(date)&#10;            },&#10;            year,&#10;            month,&#10;            day&#10;        )&#10;&#10;        // --- RESTRICCIÓN DE EDAD ---&#10;        // 1. Crear una instancia de Calendar para la fecha máxima&#10;        val maxDate = Calendar.getInstance()&#10;        // 2. Restar 18 años a la fecha actual&#10;        maxDate.add(Calendar.YEAR, -18)&#10;        // 3. Establecer esa fecha como la máxima seleccionable&#10;        datePickerDialog.datePicker.maxDate = maxDate.timeInMillis&#10;&#10;        datePickerDialog.show()&#10;    }&#10;&#10;    private fun handleRegistration() {&#10;        // (El resto del código de validación y registro permanece igual)&#10;        if (validateFields()) {&#10;            val name = etName.text.toString().trim()&#10;            val email = etEmailRegister.text.toString().trim()&#10;            val birthDate = etBirthDate.text.toString()&#10;            val gender = spinnerGender.selectedItem.toString()&#10;            val password = etPasswordRegister.text.toString()&#10;&#10;            // Cifrar la contraseña antes de guardarla&#10;            val encryptedPassword = EncryptionUtil.encryptPassword(password)&#10;&#10;            val newUser = UsuarioEntity(&#10;                name = name,&#10;                email = email,&#10;                birthDate = birthDate,&#10;                gender = gender,&#10;                passwordHash = encryptedPassword&#10;            )&#10;&#10;            scope.launch {&#10;                val isRegistered = usuarioDao.isEmailRegistered(email)&#10;                withContext(Dispatchers.Main) {&#10;                    if (isRegistered) {&#10;                        etEmailRegister.error = &quot;Este correo ya está registrado.&quot;&#10;                        Toast.makeText(this@RegisterActivity, &quot;El correo ya existe.&quot;, Toast.LENGTH_LONG).show()&#10;                    } else {&#10;                        try {&#10;                            usuarioDao.insertar(newUser)&#10;                            firebaseService.guardarUsuario(newUser)&#10;&#10;                            Toast.makeText(this@RegisterActivity, &quot;¡Registro Exitoso! Ahora inicia sesión.&quot;, Toast.LENGTH_LONG).show()&#10;&#10;                            // Guardar sesión automáticamente para mantener al usuario logueado&#10;                            val prefs = getSharedPreferences(&quot;user_data&quot;, MODE_PRIVATE)&#10;                            prefs.edit().apply {&#10;                                putString(&quot;user_email&quot;, email)&#10;                                putString(&quot;user_name&quot;, name)&#10;                                apply()&#10;                            }&#10;&#10;                            // Redirigir a EditProfileActivity para completar perfil&#10;                            val intent = Intent(this@RegisterActivity, com.example.myapplication.ui.simulacion.EditProfileActivity::class.java)&#10;                            intent.putExtra(&quot;userEmail&quot;, email)&#10;                            startActivity(intent)&#10;                            finish()&#10;                        } catch (e: Exception) {&#10;                            Toast.makeText(this@RegisterActivity, &quot;Error al guardar el usuario: ${e.message}&quot;, Toast.LENGTH_LONG).show()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun validateFields(): Boolean {&#10;        etName.error = null&#10;        etEmailRegister.error = null&#10;        etBirthDate.error = null&#10;        etPasswordRegister.error = null&#10;        etConfirmPassword.error = null&#10;        var isValid = true&#10;&#10;        if (etName.text.toString().trim().isEmpty()) {&#10;            etName.error = &quot;El nombre es obligatorio.&quot;&#10;            isValid = false&#10;        }&#10;&#10;        val email = etEmailRegister.text.toString().trim()&#10;        if (email.isEmpty()) {&#10;            etEmailRegister.error = &quot;El correo electrónico es obligatorio.&quot;&#10;            isValid = false&#10;        } else if (!email.matches(emailRegex)) {&#10;            etEmailRegister.error = &quot;Formato de correo inválido (ej: usuario@dominio.com).&quot;&#10;            isValid = false&#10;        }&#10;&#10;        if (etBirthDate.text.toString().isEmpty()) {&#10;            etBirthDate.error = &quot;Debes seleccionar tu fecha de nacimiento.&quot;&#10;            isValid = false&#10;        }&#10;&#10;        if (spinnerGender.selectedItemPosition == 0) {&#10;            Toast.makeText(this, &quot;Por favor, selecciona tu género.&quot;, Toast.LENGTH_SHORT).show()&#10;            isValid = false&#10;        }&#10;&#10;        val password = etPasswordRegister.text.toString()&#10;        if (password.length != 8) {&#10;            etPasswordRegister.error = &quot;La contraseña debe ser de exactamente 8 caracteres.&quot;&#10;            isValid = false&#10;        }&#10;&#10;        if (etConfirmPassword.text.toString() != password) {&#10;            etConfirmPassword.error = &quot;Las contraseñas no coinciden.&quot;&#10;            isValid = false&#10;        }&#10;&#10;        if (!cbTerms.isChecked) {&#10;            Toast.makeText(this, &quot;Debes aceptar los términos y condiciones.&quot;, Toast.LENGTH_SHORT).show()&#10;            isValid = false&#10;        }&#10;&#10;        return isValid&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.myapplication.ui.register&#10;&#10;import android.app.DatePickerDialog&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.text.InputFilter&#10;import android.widget.*&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.example.myapplication.R&#10;import com.example.myapplication.cloud.FirebaseService&#10;import com.example.myapplication.database.AppDatabase&#10;import com.example.myapplication.model.UsuarioEntity&#10;import com.example.myapplication.ui.login.LoginActivity&#10;import com.example.myapplication.util.EncryptionUtil&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import java.util.*&#10;&#10;class RegisterActivity : AppCompatActivity() {&#10;&#10;    // Declaración de variables de la UI&#10;    private lateinit var etName: EditText&#10;    private lateinit var etEmailRegister: EditText&#10;    private lateinit var etBirthDate: EditText&#10;    private lateinit var spinnerGender: Spinner&#10;    private lateinit var etPasswordRegister: EditText&#10;    private lateinit var etConfirmPassword: EditText&#10;    private lateinit var cbTerms: CheckBox&#10;    private lateinit var btnRegister: Button&#10;    private lateinit var tvLoginLink: TextView&#10;    private lateinit var tvViewTerms: TextView&#10;&#10;    private val db by lazy { AppDatabase.getInstance(applicationContext) }&#10;    private val usuarioDao by lazy { db.usuarioDao() }&#10;    private val firebaseService by lazy { FirebaseService }&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private val emailRegex = Regex(&quot;[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+&quot;)&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_register)&#10;&#10;        // Inicialización de Vistas&#10;        etName = findViewById(R.id.etName)&#10;        etEmailRegister = findViewById(R.id.etEmailRegister)&#10;        etBirthDate = findViewById(R.id.etBirthDate)&#10;        spinnerGender = findViewById(R.id.spinnerGender)&#10;        etPasswordRegister = findViewById(R.id.etPasswordRegister)&#10;        etConfirmPassword = findViewById(R.id.etConfirmPassword)&#10;        cbTerms = findViewById(R.id.cbTerms)&#10;        btnRegister = findViewById(R.id.btnRegister)&#10;        tvLoginLink = findViewById(R.id.tvLoginLink)&#10;        tvViewTerms = findViewById(R.id.tvViewTerms)&#10;&#10;        setupListeners()&#10;    }&#10;&#10;    private fun setupListeners() {&#10;        etName.filters = arrayOf(InputFilter { source, _, _, _, _, _ -&gt;&#10;            if (source.toString().matches(Regex(&quot;[a-zA-ZáéíóúÁÉÍÓÚñÑ\\s]*&quot;))) source else &quot;&quot;&#10;        })&#10;&#10;        etBirthDate.setOnClickListener { showDatePickerDialog() }&#10;&#10;        btnRegister.setOnClickListener { handleRegistration() }&#10;&#10;        tvLoginLink.setOnClickListener {&#10;            val intent = Intent(this, LoginActivity::class.java)&#10;            startActivity(intent)&#10;            finish()&#10;        }&#10;&#10;        tvViewTerms.setOnClickListener {&#10;            val intent = Intent(this, TermsAndConditionsActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;    }&#10;&#10;    private fun showDatePickerDialog() {&#10;        val calendar = Calendar.getInstance()&#10;        val year = calendar.get(Calendar.YEAR)&#10;        val month = calendar.get(Calendar.MONTH)&#10;        val day = calendar.get(Calendar.DAY_OF_MONTH)&#10;&#10;        val datePickerDialog = DatePickerDialog(&#10;            this,&#10;            { _, selectedYear, selectedMonth, selectedDay -&gt;&#10;                val date = &quot;${selectedDay.toString().padStart(2, '0')}/${(selectedMonth + 1).toString().padStart(2, '0')}/${selectedYear}&quot;&#10;                etBirthDate.setText(date)&#10;            },&#10;            year,&#10;            month,&#10;            day&#10;        )&#10;&#10;        // --- RESTRICCIÓN DE EDAD ---&#10;        // 1. Crear una instancia de Calendar para la fecha máxima&#10;        val maxDate = Calendar.getInstance()&#10;        // 2. Restar 18 años a la fecha actual&#10;        maxDate.add(Calendar.YEAR, -18)&#10;        // 3. Establecer esa fecha como la máxima seleccionable&#10;        datePickerDialog.datePicker.maxDate = maxDate.timeInMillis&#10;&#10;        datePickerDialog.show()&#10;    }&#10;&#10;    private fun handleRegistration() {&#10;        // (El resto del código de validación y registro permanece igual)&#10;        if (validateFields()) {&#10;            val name = etName.text.toString().trim()&#10;            val email = etEmailRegister.text.toString().trim()&#10;            val birthDate = etBirthDate.text.toString()&#10;            val gender = spinnerGender.selectedItem.toString()&#10;            val password = etPasswordRegister.text.toString()&#10;&#10;            // Cifrar la contraseña antes de guardarla&#10;            val encryptedPassword = EncryptionUtil.encryptPassword(password)&#10;&#10;            val newUser = UsuarioEntity(&#10;                name = name,&#10;                email = email,&#10;                birthDate = birthDate,&#10;                gender = gender,&#10;                passwordHash = encryptedPassword&#10;            )&#10;&#10;            scope.launch {&#10;                // Verificar en base de datos local (Room)&#10;                val isRegisteredLocally = usuarioDao.isEmailRegistered(email)&#10;&#10;                if (isRegisteredLocally) {&#10;                    withContext(Dispatchers.Main) {&#10;                        etEmailRegister.error = &quot;Este correo ya está registrado&quot;&#10;                        Toast.makeText(&#10;                            this@RegisterActivity,&#10;                            &quot;❌ Ya existe una cuenta con este correo electrónico.\n¿Olvidaste tu contraseña?&quot;,&#10;                            Toast.LENGTH_LONG&#10;                        ).show()&#10;                        android.util.Log.w(&quot;RegisterActivity&quot;, &quot;⚠️ Intento de registro con correo duplicado (local): $email&quot;)&#10;                    }&#10;                    return@launch&#10;                }&#10;&#10;                // Verificar también en Firebase (por si el usuario se registró en otro dispositivo)&#10;                FirebaseService.findUserByEmail(email) { firebaseUser -&gt;&#10;                    if (firebaseUser != null) {&#10;                        runOnUiThread {&#10;                            etEmailRegister.error = &quot;Este correo ya está registrado&quot;&#10;                            Toast.makeText(&#10;                                this@RegisterActivity,&#10;                                &quot;❌ Ya existe una cuenta con este correo en la nube.\nIntenta iniciar sesión.&quot;,&#10;                                Toast.LENGTH_LONG&#10;                            ).show()&#10;                            android.util.Log.w(&quot;RegisterActivity&quot;, &quot;⚠️ Intento de registro con correo duplicado (Firebase): $email&quot;)&#10;                        }&#10;                        return@findUserByEmail&#10;                    }&#10;&#10;                    // Correo NO está duplicado, proceder con el registro&#10;                    runOnUiThread {&#10;                        scope.launch {&#10;                            try {&#10;                                // Guardar en Room (local)&#10;                                usuarioDao.insertar(newUser)&#10;&#10;                                // Guardar en Firebase (nube)&#10;                                firebaseService.guardarUsuario(newUser)&#10;&#10;                                withContext(Dispatchers.Main) {&#10;                                    Toast.makeText(&#10;                                        this@RegisterActivity,&#10;                                        &quot;✅ ¡Registro Exitoso! Completa tu perfil.&quot;,&#10;                                        Toast.LENGTH_LONG&#10;                                    ).show()&#10;                                    android.util.Log.d(&quot;RegisterActivity&quot;, &quot;✅ Usuario registrado exitosamente: $email&quot;)&#10;&#10;                                    // Guardar sesión automáticamente&#10;                                    val prefs = getSharedPreferences(&quot;user_data&quot;, MODE_PRIVATE)&#10;                                    prefs.edit().apply {&#10;                                        putString(&quot;user_email&quot;, email)&#10;                                        putString(&quot;user_name&quot;, name)&#10;                                        apply()&#10;                                    }&#10;&#10;                                    // Redirigir a EditProfileActivity para completar perfil&#10;                                    val intent = Intent(this@RegisterActivity, com.example.myapplication.ui.simulacion.EditProfileActivity::class.java)&#10;                                    intent.putExtra(&quot;userEmail&quot;, email)&#10;                                    startActivity(intent)&#10;                                    finish()&#10;                                }&#10;                            } catch (e: Exception) {&#10;                                withContext(Dispatchers.Main) {&#10;                                    Toast.makeText(&#10;                                        this@RegisterActivity,&#10;                                        &quot;❌ Error al guardar: ${e.message}&quot;,&#10;                                        Toast.LENGTH_LONG&#10;                                    ).show()&#10;                                    android.util.Log.e(&quot;RegisterActivity&quot;, &quot;❌ Error al registrar usuario: ${e.message}&quot;, e)&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun validateFields(): Boolean {&#10;        etName.error = null&#10;        etEmailRegister.error = null&#10;        etBirthDate.error = null&#10;        etPasswordRegister.error = null&#10;        etConfirmPassword.error = null&#10;        var isValid = true&#10;&#10;        if (etName.text.toString().trim().isEmpty()) {&#10;            etName.error = &quot;El nombre es obligatorio.&quot;&#10;            isValid = false&#10;        }&#10;&#10;        val email = etEmailRegister.text.toString().trim()&#10;        if (email.isEmpty()) {&#10;            etEmailRegister.error = &quot;El correo electrónico es obligatorio.&quot;&#10;            isValid = false&#10;        } else if (!email.matches(emailRegex)) {&#10;            etEmailRegister.error = &quot;Formato de correo inválido (ej: usuario@dominio.com).&quot;&#10;            isValid = false&#10;        }&#10;&#10;        if (etBirthDate.text.toString().isEmpty()) {&#10;            etBirthDate.error = &quot;Debes seleccionar tu fecha de nacimiento.&quot;&#10;            isValid = false&#10;        }&#10;&#10;        if (spinnerGender.selectedItemPosition == 0) {&#10;            Toast.makeText(this, &quot;Por favor, selecciona tu género.&quot;, Toast.LENGTH_SHORT).show()&#10;            isValid = false&#10;        }&#10;&#10;        val password = etPasswordRegister.text.toString()&#10;        val confirmPassword = etConfirmPassword.text.toString()&#10;        &#10;        // Validar contraseña con PasswordValidator&#10;        val passwordValidation = com.example.myapplication.util.PasswordValidator.validate(password)&#10;        if (!passwordValidation.isValid) {&#10;            etPasswordRegister.error = com.example.myapplication.util.PasswordValidator.getErrorMessage(passwordValidation)&#10;            isValid = false&#10;        }&#10;&#10;        // Verificar que las contraseñas coincidan&#10;        if (!com.example.myapplication.util.PasswordValidator.passwordsMatch(password, confirmPassword)) {&#10;            etConfirmPassword.error = &quot;Las contraseñas no coinciden&quot;&#10;            isValid = false&#10;        }&#10;&#10;        if (!cbTerms.isChecked) {&#10;            Toast.makeText(this, &quot;Debes aceptar los términos y condiciones.&quot;, Toast.LENGTH_SHORT).show()&#10;            isValid = false&#10;        }&#10;&#10;        return isValid&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/util/PasswordValidator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/myapplication/util/PasswordValidator.kt" />
              <option name="updatedContent" value="package com.example.myapplication.util&#10;&#10;/**&#10; * Utilidad para validar contraseñas con requisitos de seguridad&#10; */&#10;object PasswordValidator {&#10;    &#10;    /**&#10;     * Resultado de la validación de contraseña&#10;     */&#10;    data class ValidationResult(&#10;        val isValid: Boolean,&#10;        val errors: List&lt;String&gt; = emptyList(),&#10;        val meetsLength: Boolean = false,&#10;        val meetsUppercase: Boolean = false,&#10;        val meetsNumber: Boolean = false&#10;    )&#10;    &#10;    /**&#10;     * Requisitos mínimos de contraseña&#10;     */&#10;    const val MIN_LENGTH = 8&#10;    &#10;    /**&#10;     * Valida una contraseña con todos los requisitos&#10;     */&#10;    fun validate(password: String): ValidationResult {&#10;        val errors = mutableListOf&lt;String&gt;()&#10;        &#10;        // Verificar longitud mínima&#10;        val meetsLength = password.length &gt;= MIN_LENGTH&#10;        if (!meetsLength) {&#10;            errors.add(&quot;La contraseña debe tener al menos $MIN_LENGTH caracteres&quot;)&#10;        }&#10;        &#10;        // Verificar mayúscula&#10;        val meetsUppercase = password.any { it.isUpperCase() }&#10;        if (!meetsUppercase) {&#10;            errors.add(&quot;La contraseña debe contener al menos una letra mayúscula&quot;)&#10;        }&#10;        &#10;        // Verificar número&#10;        val meetsNumber = password.any { it.isDigit() }&#10;        if (!meetsNumber) {&#10;            errors.add(&quot;La contraseña debe contener al menos un número&quot;)&#10;        }&#10;        &#10;        return ValidationResult(&#10;            isValid = errors.isEmpty(),&#10;            errors = errors,&#10;            meetsLength = meetsLength,&#10;            meetsUppercase = meetsUppercase,&#10;            meetsNumber = meetsNumber&#10;        )&#10;    }&#10;    &#10;    /**&#10;     * Verifica que las dos contraseñas coincidan&#10;     */&#10;    fun passwordsMatch(password: String, confirmPassword: String): Boolean {&#10;        return password == confirmPassword&#10;    }&#10;    &#10;    /**&#10;     * Obtiene un mensaje de error amigable para el usuario&#10;     */&#10;    fun getErrorMessage(result: ValidationResult): String {&#10;        return when {&#10;            result.errors.isEmpty() -&gt; &quot;&quot;&#10;            result.errors.size == 1 -&gt; result.errors[0]&#10;            else -&gt; &quot;La contraseña no cumple los requisitos:\n${result.errors.joinToString(&quot;\n• &quot;, &quot;• &quot;)}&quot;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/circle_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/circle_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;oval&quot;&gt;&#10;    &lt;solid android:color=&quot;#9C27B0&quot; /&gt;&#10;&lt;/shape&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/gradient_background_login.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/gradient_background_login.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &lt;gradient&#10;        android:angle=&quot;135&quot;&#10;        android:startColor=&quot;#9C27B0&quot;&#10;        android:centerColor=&quot;#7B1FA2&quot;&#10;        android:endColor=&quot;#54075D&quot;&#10;        android:type=&quot;linear&quot; /&gt;&#10;&lt;/shape&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_check_circle.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_check_circle.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#4CAF50&quot;&#10;        android:pathData=&quot;M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM10,17l-5,-5 1.41,-1.41L10,14.17l7.59,-7.59L19,8l-9,9z&quot;/&gt;&#10;&lt;/vector&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_circle_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_circle_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#757575&quot;&#10;        android:pathData=&quot;M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.42,0 -8,-3.58 -8,-8s3.58,-8 8,-8 8,3.58 8,8 -3.58,8 -8,8z&quot;/&gt;&#10;&lt;/vector&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_lock_reset.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_lock_reset.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#FFFFFF&quot;&#10;        android:pathData=&quot;M18,8h-1L17,6c0,-2.76 -2.24,-5 -5,-5S7,3.24 7,6v2L6,8c-1.1,0 -2,0.9 -2,2v10c0,1.1 0.9,2 2,2h12c1.1,0 2,-0.9 2,-2L20,10c0,-1.1 -0.9,-2 -2,-2zM12,17c-1.1,0 -2,-0.9 -2,-2s0.9,-2 2,-2 2,0.9 2,2 -0.9,2 -2,2zM15.1,8L8.9,8L8.9,6c0,-1.71 1.39,-3.1 3.1,-3.1 1.71,0 3.1,1.39 3.1,3.1v2z&quot;/&gt;&#10;&lt;/vector&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/rounded_background_light.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/rounded_background_light.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &lt;solid android:color=&quot;#F9F9F9&quot; /&gt;&#10;    &lt;corners android:radius=&quot;8dp&quot; /&gt;&#10;&lt;/shape&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/rounded_input_readonly.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/rounded_input_readonly.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:shape=&quot;rectangle&quot;&gt;&#10;    &lt;solid android:color=&quot;#F5F5F5&quot; /&gt;&#10;    &lt;corners android:radius=&quot;12dp&quot; /&gt;&#10;    &lt;stroke&#10;        android:width=&quot;1dp&quot;&#10;        android:color=&quot;#E0E0E0&quot; /&gt;&#10;&lt;/shape&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_login.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_login.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:fillViewport=&quot;true&quot;&#10;    android:background=&quot;@drawable/splash_gradient_background&quot;&gt;&#10;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    tools:context=&quot;.ui.login.LoginActivity&quot;&gt;&#10;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/ivLoginBackgroundOverlay&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:src=&quot;@drawable/imagen_login&quot;&#10;        android:scaleType=&quot;centerCrop&quot;&#10;        android:contentDescription=&quot;@string/app_name&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        android:alpha=&quot;0.5&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvLoginTitle&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;40dp&quot;&#10;        android:text=&quot;@string/login_main_title&quot;&#10;        android:textColor=&quot;@color/tamats_pink&quot;&#10;        android:textSize=&quot;44sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:letterSpacing=&quot;0.05&quot;&#10;        android:shadowColor=&quot;#40000000&quot;&#10;        android:shadowDx=&quot;0&quot;&#10;        android:shadowDy=&quot;4&quot;&#10;        android:shadowRadius=&quot;8&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;androidx.cardview.widget.CardView&#10;        android:id=&quot;@+id/cvLoginFormCard&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;24dp&quot;&#10;        android:layout_marginEnd=&quot;24dp&quot;&#10;        android:layout_marginTop=&quot;20dp&quot;&#10;        app:cardCornerRadius=&quot;20dp&quot;&#10;        app:cardElevation=&quot;8dp&quot;&#10;        app:cardBackgroundColor=&quot;@color/register_card_background_color&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/tvLoginTitle&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:padding=&quot;24dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvWelcome&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;@string/login_welcome_back&quot;&#10;            android:textColor=&quot;@color/black&quot;&#10;            android:textSize=&quot;22sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:gravity=&quot;center&quot;&#10;            android:letterSpacing=&quot;0.02&quot; /&gt;&#10;&#10;        &lt;EditText&#10;            android:id=&quot;@+id/etEmail&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;20dp&quot;&#10;            android:background=&quot;@drawable/edit_text_rounded_background&quot;&#10;            android:hint=&quot;@string/login_email_hint&quot;&#10;            android:inputType=&quot;textEmailAddress&quot;&#10;            android:autofillHints=&quot;emailAddress&quot;&#10;            android:padding=&quot;14dp&quot;&#10;            android:textColor=&quot;@android:color/black&quot;&#10;            android:textColorHint=&quot;#999999&quot;&#10;            android:textSize=&quot;15sp&quot; /&gt;&#10;&#10;        &lt;EditText&#10;            android:id=&quot;@+id/etPassword&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;12dp&quot;&#10;            android:background=&quot;@drawable/edit_text_rounded_background&quot;&#10;            android:hint=&quot;@string/login_password_hint&quot;&#10;            android:inputType=&quot;textPassword&quot;&#10;            android:autofillHints=&quot;password&quot;&#10;            android:padding=&quot;14dp&quot;&#10;            android:textColor=&quot;@android:color/black&quot;&#10;            android:textColorHint=&quot;#999999&quot;&#10;            android:textSize=&quot;15sp&quot; /&gt;&#10;&#10;        &lt;com.google.android.material.button.MaterialButton&#10;            android:id=&quot;@+id/btnLogin&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;20dp&quot;&#10;            android:backgroundTint=&quot;@android:color/black&quot;&#10;            android:paddingTop=&quot;12dp&quot;&#10;            android:paddingBottom=&quot;12dp&quot;&#10;            android:text=&quot;@string/login_button_text&quot;&#10;            android:textColor=&quot;@android:color/white&quot;&#10;            android:textSize=&quot;16sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            app:cornerRadius=&quot;24dp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvOrDivider&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;16dp&quot;&#10;            android:text=&quot;@string/login_or_divider&quot;&#10;            android:textColor=&quot;#666666&quot;&#10;            android:textSize=&quot;14sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:gravity=&quot;center&quot; /&gt;&#10;&#10;        &lt;com.google.android.material.button.MaterialButton&#10;            android:id=&quot;@+id/btnFacebook&quot;&#10;            style=&quot;@style/Widget.MaterialComponents.Button.OutlinedButton&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;14dp&quot;&#10;            android:backgroundTint=&quot;@android:color/white&quot;&#10;            android:paddingTop=&quot;12dp&quot;&#10;            android:paddingBottom=&quot;12dp&quot;&#10;            android:text=&quot;@string/login_facebook_button&quot;&#10;            android:textColor=&quot;@android:color/black&quot;&#10;            android:textSize=&quot;13sp&quot;&#10;            app:cornerRadius=&quot;24dp&quot;&#10;            app:strokeColor=&quot;#E0E0E0&quot;&#10;            app:strokeWidth=&quot;1dp&quot;&#10;            app:icon=&quot;@drawable/facebook_com&quot;&#10;            app:iconTint=&quot;@android:color/black&quot;&#10;            app:iconGravity=&quot;textStart&quot; /&gt;&#10;&#10;        &lt;com.google.android.material.button.MaterialButton&#10;            android:id=&quot;@+id/btnGoogle&quot;&#10;            style=&quot;@style/Widget.MaterialComponents.Button.OutlinedButton&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;10dp&quot;&#10;            android:backgroundTint=&quot;@android:color/white&quot;&#10;            android:paddingTop=&quot;12dp&quot;&#10;            android:paddingBottom=&quot;12dp&quot;&#10;            android:text=&quot;@string/login_google_button&quot;&#10;            android:textColor=&quot;@android:color/black&quot;&#10;            android:textSize=&quot;13sp&quot;&#10;            app:cornerRadius=&quot;24dp&quot;&#10;            app:strokeColor=&quot;#E0E0E0&quot;&#10;            app:strokeWidth=&quot;1dp&quot;&#10;            app:icon=&quot;@drawable/gmail_com&quot;&#10;            app:iconTint=&quot;@android:color/black&quot;&#10;            app:iconGravity=&quot;textStart&quot; /&gt;&#10;&#10;        &lt;com.google.android.material.button.MaterialButton&#10;            android:id=&quot;@+id/btnTwitter&quot;&#10;            style=&quot;@style/Widget.MaterialComponents.Button.OutlinedButton&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;10dp&quot;&#10;            android:backgroundTint=&quot;@android:color/white&quot;&#10;            android:paddingTop=&quot;12dp&quot;&#10;            android:paddingBottom=&quot;12dp&quot;&#10;            android:text=&quot;@string/login_twitter_button&quot;&#10;            android:textColor=&quot;@android:color/black&quot;&#10;            android:textSize=&quot;13sp&quot;&#10;            app:cornerRadius=&quot;24dp&quot;&#10;            app:strokeColor=&quot;#E0E0E0&quot;&#10;            app:strokeWidth=&quot;1dp&quot;&#10;            app:icon=&quot;@drawable/x_com&quot;&#10;            app:iconTint=&quot;@android:color/black&quot;&#10;            app:iconGravity=&quot;textStart&quot; /&gt;&#10;&#10;        &lt;LinearLayout&#10;            android:id=&quot;@+id/llRegister&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:orientation=&quot;horizontal&quot;&#10;            android:layout_marginTop=&quot;18dp&quot;&#10;            android:gravity=&quot;center&quot;&gt;&#10;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/tvNewUserPrompt&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:text=&quot;@string/login_new_user_prompt&quot;&#10;                android:textColor=&quot;#666666&quot;&#10;                android:textSize=&quot;14sp&quot; /&gt;&#10;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/tvRegisterLink&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:layout_marginStart=&quot;4dp&quot;&#10;                android:text=&quot;@string/login_register_link&quot;&#10;                android:textColor=&quot;@color/tamats_pink&quot;&#10;                android:textSize=&quot;14sp&quot;&#10;                android:textStyle=&quot;bold&quot;/&gt;&#10;        &lt;/LinearLayout&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;    &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvCopyright&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:layout_marginBottom=&quot;20dp&quot;&#10;        android:text=&quot;@string/login_copyright&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;12sp&quot;&#10;        android:shadowColor=&quot;#80000000&quot;&#10;        android:shadowDx=&quot;0&quot;&#10;        android:shadowDy=&quot;2&quot;&#10;        android:shadowRadius=&quot;4&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/cvLoginFormCard&quot;&#10;        app:layout_constraintVertical_bias=&quot;1.0&quot;/&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;&lt;/ScrollView&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:fillViewport=&quot;true&quot;&#10;    android:background=&quot;@drawable/splash_gradient_background&quot;&gt;&#10;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;wrap_content&quot;&#10;    tools:context=&quot;.ui.login.LoginActivity&quot;&gt;&#10;&#10;    &lt;ImageView&#10;        android:id=&quot;@+id/ivLoginBackgroundOverlay&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:src=&quot;@drawable/imagen_login&quot;&#10;        android:scaleType=&quot;centerCrop&quot;&#10;        android:contentDescription=&quot;@string/app_name&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        android:alpha=&quot;0.5&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvLoginTitle&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;60dp&quot;&#10;        android:text=&quot;@string/login_main_title&quot;&#10;        android:textColor=&quot;@color/tamats_pink&quot;&#10;        android:textSize=&quot;48sp&quot;&#10;        android:textStyle=&quot;bold&quot;&#10;        android:letterSpacing=&quot;0.05&quot;&#10;        android:shadowColor=&quot;#40000000&quot;&#10;        android:shadowDx=&quot;0&quot;&#10;        android:shadowDy=&quot;4&quot;&#10;        android:shadowRadius=&quot;8&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;&#10;&#10;    &lt;androidx.cardview.widget.CardView&#10;        android:id=&quot;@+id/cvLoginFormCard&quot;&#10;        android:layout_width=&quot;0dp&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginStart=&quot;24dp&quot;&#10;        android:layout_marginEnd=&quot;24dp&quot;&#10;        android:layout_marginTop=&quot;32dp&quot;&#10;        app:cardCornerRadius=&quot;20dp&quot;&#10;        app:cardElevation=&quot;12dp&quot;&#10;        app:cardBackgroundColor=&quot;@color/register_card_background_color&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/tvLoginTitle&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:padding=&quot;24dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvWelcome&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;@string/login_welcome_back&quot;&#10;            android:textColor=&quot;@color/black&quot;&#10;            android:textSize=&quot;22sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:gravity=&quot;center&quot;&#10;            android:letterSpacing=&quot;0.02&quot; /&gt;&#10;&#10;        &lt;EditText&#10;            android:id=&quot;@+id/etEmail&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;20dp&quot;&#10;            android:background=&quot;@drawable/edit_text_rounded_background&quot;&#10;            android:hint=&quot;@string/login_email_hint&quot;&#10;            android:inputType=&quot;textEmailAddress&quot;&#10;            android:autofillHints=&quot;emailAddress&quot;&#10;            android:padding=&quot;14dp&quot;&#10;            android:textColor=&quot;@android:color/black&quot;&#10;            android:textColorHint=&quot;#999999&quot;&#10;            android:textSize=&quot;15sp&quot; /&gt;&#10;&#10;        &lt;EditText&#10;            android:id=&quot;@+id/etPassword&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;12dp&quot;&#10;            android:background=&quot;@drawable/edit_text_rounded_background&quot;&#10;            android:hint=&quot;@string/login_password_hint&quot;&#10;            android:inputType=&quot;textPassword&quot;&#10;            android:autofillHints=&quot;password&quot;&#10;            android:padding=&quot;14dp&quot;&#10;            android:textColor=&quot;@android:color/black&quot;&#10;            android:textColorHint=&quot;#999999&quot;&#10;            android:textSize=&quot;15sp&quot; /&gt;&#10;&#10;        &lt;!-- Enlace Olvidé mi contraseña - Mejorado --&gt;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/tvForgotPassword&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_gravity=&quot;end&quot;&#10;            android:layout_marginTop=&quot;12dp&quot;&#10;            android:layout_marginEnd=&quot;4dp&quot;&#10;            android:text=&quot;¿Olvidaste tu contraseña?&quot;&#10;            android:textColor=&quot;#9C27B0&quot;&#10;            android:textSize=&quot;14sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:clickable=&quot;true&quot;&#10;            android:focusable=&quot;true&quot;&#10;            android:padding=&quot;8dp&quot; /&gt;&#10;&#10;        &lt;!-- Botón de Login - Ancho según contenido, centrado --&gt;&#10;        &lt;com.google.android.material.button.MaterialButton&#10;            android:id=&quot;@+id/btnLogin&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;56dp&quot;&#10;            android:layout_gravity=&quot;center&quot;&#10;            android:layout_marginTop=&quot;28dp&quot;&#10;            android:backgroundTint=&quot;@android:color/black&quot;&#10;            android:text=&quot;@string/login_button_text&quot;&#10;            android:textColor=&quot;@android:color/white&quot;&#10;            android:textSize=&quot;16sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:paddingStart=&quot;48dp&quot;&#10;            android:paddingEnd=&quot;48dp&quot;&#10;            app:cornerRadius=&quot;28dp&quot;&#10;            app:elevation=&quot;6dp&quot;&#10;            app:iconGravity=&quot;textStart&quot; /&gt;&#10;&#10;        &lt;LinearLayout&#10;            android:id=&quot;@+id/llRegister&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:orientation=&quot;horizontal&quot;&#10;            android:layout_marginTop=&quot;18dp&quot;&#10;            android:gravity=&quot;center&quot;&gt;&#10;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/tvNewUserPrompt&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:text=&quot;@string/login_new_user_prompt&quot;&#10;                android:textColor=&quot;#666666&quot;&#10;                android:textSize=&quot;14sp&quot; /&gt;&#10;&#10;            &lt;TextView&#10;                android:id=&quot;@+id/tvRegisterLink&quot;&#10;                android:layout_width=&quot;wrap_content&quot;&#10;                android:layout_height=&quot;wrap_content&quot;&#10;                android:layout_marginStart=&quot;4dp&quot;&#10;                android:text=&quot;@string/login_register_link&quot;&#10;                android:textColor=&quot;@color/tamats_pink&quot;&#10;                android:textSize=&quot;14sp&quot;&#10;                android:textStyle=&quot;bold&quot;/&gt;&#10;        &lt;/LinearLayout&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;    &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/tvCopyright&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:layout_marginTop=&quot;16dp&quot;&#10;        android:layout_marginBottom=&quot;20dp&quot;&#10;        android:text=&quot;@string/login_copyright&quot;&#10;        android:textColor=&quot;@android:color/white&quot;&#10;        android:textSize=&quot;12sp&quot;&#10;        android:shadowColor=&quot;#80000000&quot;&#10;        android:shadowDx=&quot;0&quot;&#10;        android:shadowDy=&quot;2&quot;&#10;        android:shadowRadius=&quot;4&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toBottomOf=&quot;@id/cvLoginFormCard&quot;&#10;        app:layout_constraintVertical_bias=&quot;1.0&quot;/&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;&lt;/ScrollView&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>